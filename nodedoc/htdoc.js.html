<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: htdoc.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: htdoc.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
* Hashtable module.
* @module ht
*/

/**
	* String-string hashmap 
	* @classdesc Used for storing key/data pairs, wrapps an efficient C++ implementation.
	* @class
	* @example
	* // create a new hashtable
	* ht = require('qminer').ht;
	* var h = new ht.StrStrMap();
	* // Adding two key/dat pairs
	* h.put('foo', 'bar');
	* h.put('dog', 'tisa');
	* // Getting data
	* h.hasKey('foo'); // returns true
	* h.get('dog'); // returns 'tisa'
	* h.key(1); // returns 'dog'
	* h.dat(1); // returns 'tisa'
	* h.length; // returns 2
	* // Saving and loading:
	* var fs = require('qminer').fs;
	* fout = fs.openWrite('map.dat'); // open write stream
	* h.save(fout).close(); // save and close write stream
	* var h2 = new ht.StrStrMap(); // new empty table
	* var fin = fs.openRead('map.dat'); // open read stream
	* h2.load(fin); // load
	*/
 exports.StrStrMap = function() {}
/**
	* Returns dat given key
	* @param {string} key - Hashmap key.
	* @returns {string} Hashmap data.
	*/
 exports.StrStrMap.prototype.get = function(key) {}
/**
	* add/update key-value pair
	* @param {string} key - Hashmap key.
	* @param {string} data - Hashmap data.
	* @returns {module:ht.StrStrMap} Self.
	*/
 exports.StrStrMap.prototype.put = function(key, data) {}
/**
	* returns true if the map has a given key 
	* @param {string} key - Hashmap key.	
	* @returns {boolean} True if the map contains key.
	*/
 exports.StrStrMap.prototype.hasKey = function(key) {}
/**
    * @property {number} length - Number of key/dat pairs
	*/
 exports.StrStrMap.prototype.length = undefined;
/**
	* returns n-th key
	* @param {number} n - Hashmap key number. Should be between 0 and length-1.	
	* @returns {string} n-th key.
	*/
 exports.StrStrMap.prototype.key = function(n) {}	
/**
	* returns n-th dat
	* @param {number} n - Hashmap dat number. Should be between 0 and length-1
	* @returns {string} n-th data value.
	*/
 exports.StrStrMap.prototype.dat = function(n) {}
/**
	* loads the hashtable from input stream
	* @param {module:fs.FIn} fin - Input stream.	
	* @returns {module:ht.StrStrMap} Self.
	*/
 exports.StrStrMap.prototype.load = function(fin) {}
/**
	* saves the hashtable to output stream
	* @param {module:fs.FOut} fout - Output stream.	
	* @returns {module:fs.FOut} fout.
	*/
 exports.StrStrMap.prototype.save = function(fout) {}

/**
	* String-Integer hashmap 
	* @classdesc Used for storing key/data pairs, wrapps an efficient C++ implementation.
	* @class
	* @example
	* // create a new hashtable
	* ht = require('qminer').ht;
	* var h = new ht.StrIntMap();
	* // Adding two key/dat pairs
	* h.put('foo', 10);
	* h.put('bar', 20);
	* // Getting data
	* h.hasKey('foo'); // returns true
	* h.get('bar'); // returns 20
	* h.key(1); // returns 'bar'
	* h.dat(1); // returns 20
	* h.length; // returns 2
	* // Saving and loading:
	* var fs = require('qminer').fs;
	* fout = fs.openWrite('map.dat'); // open write stream
	* h.save(fout).close(); // save and close write stream
	* var h2 = new ht.StrIntMap(); // new empty table
	* var fin = fs.openRead('map.dat'); // open read stream
	* h2.load(fin); // load
	*/
 exports.StrIntMap = function() {}
/**
	* Returns dat given key
	* @param {string} key - Hashmap key.
	* @returns {number} Hashmap data.
	*/
 exports.StrIntMap.prototype.get = function(key) {}
/**
	* add/update key-value pair
	* @param {string} key - Hashmap key.
	* @param {number} data - Hashmap data.
	* @returns {module:ht.StrIntMap} Self.
	*/
 exports.StrIntMap.prototype.put = function(key, data) {}
/**
	* returns true if the map has a given key 
	* @param {string} key - Hashmap key.	
	* @returns {boolean} True if the map contains key.
	*/
 exports.StrIntMap.prototype.hasKey = function(key) {}
/**
    * @property {number} length - Number of key/dat pairs
	*/
 exports.StrIntMap.prototype.length = undefined;
/**
	* returns n-th key
	* @param {number} n - Hashmap key number. Should be between 0 and length-1.	
	* @returns {string} n-th key.
	*/
 exports.StrIntMap.prototype.key = function(n) {}	
/**
	* returns n-th dat
	* @param {number} n - Hashmap dat number. Should be between 0 and length-1
	* @returns {number} n-th data value.
	*/
 exports.StrIntMap.prototype.dat = function(n) {}
/**
	* loads the hashtable from input stream
	* @param {module:fs.FIn} fin - Input stream.	
	* @returns {module:ht.StrIntMap} Self.
	*/
 exports.StrIntMap.prototype.load = function(fin) {}
/**
	* saves the hashtable to output stream
	* @param {module:fs.FOut} fout - Output stream.	
	* @returns {module:fs.FOut} fout.
	*/
 exports.StrIntMap.prototype.save = function(fout) {}

/**
	* String-Float hashmap 
	* @classdesc Used for storing key/data pairs, wrapps an efficient C++ implementation.
	* @class
	* @example
	* // create a new hashtable
	* ht = require('qminer').ht;
	* var h = new ht.StrFltMap();
	* // Adding two key/dat pairs
	* h.put('foo', 10.5);
	* h.put('bar', 20.2);
	* // Getting data
	* h.hasKey('foo'); // returns true
	* h.get('bar'); // returns 20.2
	* h.key(1); // returns 'bar'
	* h.dat(1); // returns 20.2
	* h.length; // returns 2
	* // Saving and loading:
	* var fs = require('qminer').fs;
	* fout = fs.openWrite('map.dat'); // open write stream
	* h.save(fout).close(); // save and close write stream
	* var h2 = new ht.StrFltMap(); // new empty table
	* var fin = fs.openRead('map.dat'); // open read stream
	* h2.load(fin); // load
	*/
 exports.StrFltMap = function() {}
/**
	* Returns dat given key
	* @param {string} key - Hashmap key.
	* @returns {number} Hashmap data.
	*/
 exports.StrFltMap.prototype.get = function(key) {}
/**
	* add/update key-value pair
	* @param {string} key - Hashmap key.
	* @param {number} data - Hashmap data.
	* @returns {module:ht.StrFltMap} Self.
	*/
 exports.StrFltMap.prototype.put = function(key, data) {}
/**
	* returns true if the map has a given key 
	* @param {string} key - Hashmap key.	
	* @returns {boolean} True if the map contains key.
	*/
 exports.StrFltMap.prototype.hasKey = function(key) {}
/**
    * @property {number} length - Number of key/dat pairs
	*/
 exports.StrFltMap.prototype.length = undefined;
/**
	* returns n-th key
	* @param {number} n - Hashmap key number. Should be between 0 and length-1.	
	* @returns {string} n-th key.
	*/
 exports.StrFltMap.prototype.key = function(n) {}	
/**
	* returns n-th dat
	* @param {number} n - Hashmap dat number. Should be between 0 and length-1
	* @returns {number} n-th data value.
	*/
 exports.StrFltMap.prototype.dat = function(n) {}
/**
	* loads the hashtable from input stream
	* @param {module:fs.FIn} fin - Input stream.	
	* @returns {module:ht.StrFltMap} Self.
	*/
 exports.StrFltMap.prototype.load = function(fin) {}
/**
	* saves the hashtable to output stream
	* @param {module:fs.FOut} fout - Output stream.	
	* @returns {module:fs.FOut} fout.
	*/
 exports.StrFltMap.prototype.save = function(fout) {}

/**
	* Int-string hashmap 
	* @classdesc Used for storing key/data pairs, wrapps an efficient C++ implementation.
	* @class
	* @example
	* // create a new hashtable
	* ht = require('qminer').ht;
	* var h = new ht.IntStrMap();
	* // Adding two key/dat pairs
	* h.put(10, 'foo');
	* h.put(20, 'bar');
	* // Getting data
	* h.hasKey(10); // returns true
	* h.get(20); // returns 'bar'
	* h.key(1); // returns 20
	* h.dat(1); // returns 'bar'
	* h.length; // returns 2
	* // Saving and loading:
	* var fs = require('qminer').fs;
	* fout = fs.openWrite('map.dat'); // open write stream
	* h.save(fout).close(); // save and close write stream
	* var h2 = new ht.IntStrMap(); // new empty table
	* var fin = fs.openRead('map.dat'); // open read stream
	* h2.load(fin); // load
	*/
 exports.IntStrMap = function() {}
/**
	* Returns dat given key
	* @param {number} key - Hashmap key.
	* @returns {string} Hashmap data.
	*/
 exports.IntStrMap.prototype.get = function(key) {}
/**
	* add/update key-value pair
	* @param {number} key - Hashmap key.
	* @param {string} data - Hashmap data.
	* @returns {module:ht.IntStrMap} Self.
	*/
 exports.IntStrMap.prototype.put = function(key, data) {}
/**
	* returns true if the map has a given key 
	* @param {number} key - Hashmap key.	
	* @returns {boolean} True if the map contains key.
	*/
 exports.IntStrMap.prototype.hasKey = function(key) {}
/**
    * @property {number} length - Number of key/dat pairs
	*/
 exports.IntStrMap.prototype.length = undefined;
/**
	* returns n-th key
	* @param {number} n - Hashmap key number. Should be between 0 and length-1.	
	* @returns {number} n-th key.
	*/
 exports.IntStrMap.prototype.key = function(n) {}	
/**
	* returns n-th dat
	* @param {number} n - Hashmap dat number. Should be between 0 and length-1
	* @returns {string} n-th data value.
	*/
 exports.IntStrMap.prototype.dat = function(n) {}
/**
	* loads the hashtable from input stream
	* @param {module:fs.FIn} fin - Input stream.	
	* @returns {module:ht.IntStrMap} Self.
	*/
 exports.IntStrMap.prototype.load = function(fin) {}
/**
	* saves the hashtable to output stream
	* @param {module:fs.FOut} fout - Output stream.	
	* @returns {module:fs.FOut} fout.
	*/
 exports.IntStrMap.prototype.save = function(fout) {}

/**
	* Integer-Integer hashmap 
	* @classdesc Used for storing key/data pairs, wrapps an efficient C++ implementation.
	* @class
	* @example
	* // create a new hashtable
	* ht = require('qminer').ht;
	* var h = new ht.IntIntMap();
	* // Adding two key/dat pairs
	* h.put(5, 10);
	* h.put(15, 20);
	* // Getting data
	* h.hasKey(5); // returns true
	* h.get(15); // returns 20
	* h.key(1); // returns 15
	* h.dat(1); // returns 20
	* h.length; // returns 2
	* // Saving and loading:
	* var fs = require('qminer').fs;
	* fout = fs.openWrite('map.dat'); // open write stream
	* h.save(fout).close(); // save and close write stream
	* var h2 = new ht.IntIntMap(); // new empty table
	* var fin = fs.openRead('map.dat'); // open read stream
	* h2.load(fin); // load
	*/
 exports.IntIntMap = function() {}
/**
	* Returns dat given key
	* @param {number} key - Hashmap key.
	* @returns {number} Hashmap data.
	*/
 exports.IntIntMap.prototype.get = function(key) {}
/**
	* add/update key-value pair
	* @param {number} key - Hashmap key.
	* @param {number} data - Hashmap data.
	* @returns {module:ht.IntIntMap} Self.
	*/
 exports.IntIntMap.prototype.put = function(key, data) {}
/**
	* returns true if the map has a given key 
	* @param {number} key - Hashmap key.	
	* @returns {boolean} True if the map contains key.
	*/
 exports.IntIntMap.prototype.hasKey = function(key) {}
/**
    * @property {number} length - Number of key/dat pairs
	*/
 exports.IntIntMap.prototype.length = undefined;
/**
	* returns n-th key
	* @param {number} n - Hashmap key number. Should be between 0 and length-1.	
	* @returns {number} n-th key.
	*/
 exports.IntIntMap.prototype.key = function(n) {}	
/**
	* returns n-th dat
	* @param {number} n - Hashmap dat number. Should be between 0 and length-1
	* @returns {number} n-th data value.
	*/
 exports.IntIntMap.prototype.dat = function(n) {}
/**
	* loads the hashtable from input stream
	* @param {module:fs.FIn} fin - Input stream.	
	* @returns {module:ht.IntIntMap} Self.
	*/
 exports.IntIntMap.prototype.load = function(fin) {}
/**
	* saves the hashtable to output stream
	* @param {module:fs.FOut} fout - Output stream.	
	* @returns {module:fs.FOut} fout.
	*/
 exports.IntIntMap.prototype.save = function(fout) {}

/**
	* Integer-Float hashmap 
	* @classdesc Used for storing key/data pairs, wrapps an efficient C++ implementation.
	* @class
	* @example
	* // create a new hashtable
	* ht = require('qminer').ht;
	* var h = new ht.IntFltMap();
	* // Adding two key/dat pairs
	* h.put(5, 10.5);
	* h.put(15, 20.2);
	* // Getting data
	* h.hasKey(5); // returns true
	* h.get(15); // returns 20.2
	* h.key(1); // returns 15
	* h.dat(1); // returns 20.2
	* h.length; // returns 2
	* // Saving and loading:
	* var fs = require('qminer').fs;
	* fout = fs.openWrite('map.dat'); // open write stream
	* h.save(fout).close(); // save and close write stream
	* var h2 = new ht.IntFltMap(); // new empty table
	* var fin = fs.openRead('map.dat'); // open read stream
	* h2.load(fin); // load
	*/
 exports.IntFltMap = function() {}
/**
	* Returns dat given key
	* @param {number} key - Hashmap key.
	* @returns {number} Hashmap data.
	*/
 exports.IntFltMap.prototype.get = function(key) {}
/**
	* add/update key-value pair
	* @param {number} key - Hashmap key.
	* @param {number} data - Hashmap data.
	* @returns {module:ht.IntFltMap} Self.
	*/
 exports.IntFltMap.prototype.put = function(key, data) {}
/**
	* returns true if the map has a given key 
	* @param {number} key - Hashmap key.	
	* @returns {boolean} True if the map contains key.
	*/
 exports.IntFltMap.prototype.hasKey = function(key) {}
/**
    * @property {number} length - Number of key/dat pairs
	*/
 exports.IntFltMap.prototype.length = undefined;
/**
	* returns n-th key
	* @param {number} n - Hashmap key number. Should be between 0 and length-1.	
	* @returns {number} n-th key.
	*/
 exports.IntFltMap.prototype.key = function(n) {}	
/**
	* returns n-th dat
	* @param {number} n - Hashmap dat number. Should be between 0 and length-1
	* @returns {number} n-th data value.
	*/
 exports.IntFltMap.prototype.dat = function(n) {}
/**
	* loads the hashtable from input stream
	* @param {module:fs.FIn} fin - Input stream.	
	* @returns {module:ht.IntFltMap} Self.
	*/
 exports.IntFltMap.prototype.load = function(fin) {}
/**
	* saves the hashtable to output stream
	* @param {module:fs.FOut} fout - Output stream.	
	* @returns {module:fs.FOut} fout.
	*/
 exports.IntFltMap.prototype.save = function(fout) {}



   /**
	* classDesc	
	* @returns {string} desc - Returns class description
	*/
exports.StrStrMap.prototype.classDesc = function () { return 'This class wraps a C++ string-string hash table'; }


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-analytics.html">analytics</a></li><li><a href="module-fs.html">fs</a></li><li><a href="module-ht.html">ht</a></li></ul><h3>Classes</h3><ul><li><a href="module-analytics.HierarchMarkov.html">HierarchMarkov</a></li><li><a href="module-analytics.SVC.html">SVC</a></li><li><a href="module-analytics.SVR.html">SVR</a></li><li><a href="module-fs.FIn.html">FIn</a></li><li><a href="module-fs.FOut.html">FOut</a></li><li><a href="module-ht.IntFltMap.html">IntFltMap</a></li><li><a href="module-ht.IntIntMap.html">IntIntMap</a></li><li><a href="module-ht.IntStrMap.html">IntStrMap</a></li><li><a href="module-ht.StrFltMap.html">StrFltMap</a></li><li><a href="module-ht.StrIntMap.html">StrIntMap</a></li><li><a href="module-ht.StrStrMap.html">StrStrMap</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta2</a> on Mon Mar 16 2015 07:24:09 GMT+0100 (Central Europe Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
