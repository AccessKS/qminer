<!doctype html>
<html>
        <head>
                <meta name="generator" content="JSDoc 3">
                <meta charset="utf-8">
                <title>Source: analyticsdoc.js</title>
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
                <link href="css/baseline.css" rel="stylesheet">
        </head>
        <body onload="prettyPrint()">
                <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
        <div id="jsdoc-navbar-content">
            <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
        </div>
    </div>
</nav>

                <div id="jsdoc-body-container">
                        <div id="jsdoc-content">
                                <div id="jsdoc-content-container">
                                        <div id="jsdoc-banner" role="banner">
                                        </div>
                                        <div id="jsdoc-main" role="main">
            <header class="page-header">
                <h1>Source: analyticsdoc.js</h1>
            </header>
            <article>
                <pre class="prettyprint linenums"><code>/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 * 
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Analytics module.
 * @module analytics
 * @example
 * // import module, load dataset, create model, evaluate model
 */
/**
* SVC constructor parameters
* @typedef {Object} svcParam
* @property  {number} [svcParam.c&#x3D;1.0] - Cost parameter. Increasing the parameter forces the model to fit the training data more accurately (setting it too large may lead to overfitting) .
* @property  {number} [svcParam.j&#x3D;1.0] - Unbalance parameter. Increasing it gives more weight to the positive examples (getting a better fit on the positive training examples gets a higher priority). Setting c&#x3D;n is like adding n-1 copies of the positive training examples to the data set.
* @property  {number} [svcParam.batchSize&#x3D;1000] - Number of examples used in the subgradient estimation. Higher number of samples slows down the algorithm, but makes the local steps more accurate.
* @property  {number} [svcParam.maxIterations&#x3D;10000] - Maximum number of iterations.
* @property  {number} [svcParam.maxTime&#x3D;1] - Maximum runtime in seconds.
* @property  {number} [svcParam.minDiff&#x3D;1e-6] - Stopping criterion tolerance.
* @property  {boolean} [svcParam.verbose&#x3D;false] - Toggle verbose output in the console.
*/
/**
* SVC
* @classdesc Support Vector Machine Classifier. Implements a soft margin linear support vector classifier using the PEGASOS algorithm, see: {@link http://ttic.uchicago.edu/~nati/Publications/PegasosMPB.pdf Pegasos: Primal Estimated sub-GrAdient SOlver for SVM}.
* @class
* @param {module:fs.FIn | module:analytics~svcParam} [arg] - File input stream (loads the model from disk) or constructor parameters svcParam.
* @example
* // import modules
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
* // CLASSIFICATION WITH SVC
* // set up fake train and test data
* // four training examples with number of features &#x3D; 2
* var featureMatrix &#x3D; new la.Matrix({ rows: 2, cols: 4, random: true });
* // classification targets for four examples
* var targets &#x3D; new la.Vector([-1, -1, 1, 1]);
* // set up the classification model
* var SVC &#x3D; new analytics.SVC({ verbose: false });
* // train classifier
* SVC.fit(featureMatrix, targets);
* // set up a fake test vector
* var test &#x3D; new la.Vector([1.1, -0.5]);
* // predict the target value
* var prediction &#x3D; SVC.predict(test);
*/
 exports.SVC &#x3D; function(arg) { return Object.create(require(&#x27;qminer&#x27;).analytics.SVC.prototype); };
/**
	* Returns the SVC parameters.
	* @returns {module:analytics~svcParam} Parameters of the classifier model.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new SVC model with json
	* var SVC &#x3D; new analytics.SVC({ c: 5, j: 10, batchSize: 2000, maxIterations: 12000, maxTime: 2, minDiff: 1e-10, verbose: true });
	* // get the parameters of the SVC model
	* // returns { algorithm: &#x27;SGD&#x27; c: 5, j: 10, batchSize: 2000, maxIterations: 12000, maxTime: 2, minDiff: 1e-10, verbose: true }
	* var json &#x3D; SVC.getParams(); 
	*/
 exports.SVC.prototype.getParams &#x3D; function() { return { algorithm: &#x27;&#x27;, c: 0, j: 0, batchSize: 0, maxIterations: 0, maxTime: 0, minDiff: 0, verbose: true } };
/**
	* Sets the SVC parameters.
	* @param {module:analytics~svcParam} param - Classifier training parameters.
	* @returns {module:analytics.SVC} Self.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a default SVC model
	* var SVC &#x3D; new analytics.SVC();
	* // change the parameters of the SVC with the json { j: 5, maxIterations: 12000, minDIff: 1e-10 }
	* SVC.setParams({ j: 5, maxIterations: 12000, minDiff: 1e-10 }); // returns self
	*/
 exports.SVC.prototype.setParams &#x3D; function(param) { return Object.create(require(&#x27;qminer&#x27;).analytics.SVC.prototype); };
/**	
	* Gets the vector of coefficients of the linear model.
	* @returns {module:la.Vector} weights - Vector of coefficients of the linear model.
	* @example 
	* // import the analytics and la modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new SVC object
	* var SVC &#x3D; new analytics.SVC();
	* // create the matrix containing the input features and the input vector for each matrix.
	* var matrix &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	* var vec &#x3D; new la.Vector([1, 1, -1, -1]);
	* // fit the model
	* SVC.fit(matrix, vec);
	* // get the weights
	* var weights &#x3D; SVC.weights; // returns the coefficients of the normal vector of the hyperplane gained from the model: [1, 1]
	*/
 exports.SVC.prototype.weights &#x3D; Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype);
/**
	* Saves model to output file stream.
	* @param {module:fs.FOut} fout - Output stream.
	* @returns {module:fs.FOut} The Output stream.
	* @example
	* // import the analytics and la modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	* // create a new SVC object
	* var SVC &#x3D; new analytics.SVC();
	* // create the matrix containing the input features and the input vector for each matrix column.
	* var matrix &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);	
	* var vec &#x3D; new la.Vector([1, 0, -1, -2]);
	* // fit the model
	* SVC.fit(matrix, vec);
	* // create output stream
	* var fout &#x3D; fs.openWrite(&#x27;svc_example.bin&#x27;);
	* // save SVC object (model and parameters) to output stream and close it
	* SVC.save(fout);
	* fout.close();
	* // create input stream
	* var fin &#x3D; fs.openRead(&#x27;svc_example.bin&#x27;);
	* // create a SVC object that loads the model and parameters from input stream
	* var SVC2 &#x3D; new analytics.SVC(fin);	
	*/
 exports.SVC.prototype.save &#x3D; function(fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Sends vector through the model and returns the distance to the decision boundery.
    * @param {module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix} X - Input feature vector or matrix with feature vectors as columns.
    * @returns {number | module:la.Vector} Distance:
	* &amp;lt;br&gt;1. Real number, if input is {@link module:la.Vector} or {@link module:la.SparseVector}.
	* &amp;lt;br&gt;2. {@link module:la.Vector}, if input is {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
	* &amp;lt;br&gt;Sign of the number corresponds to the class and the magnitude corresponds to the distance from the margin (certainty).
    * @example
	* // import the analytics and la modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new SVC object
	* var SVC &#x3D; new analytics.SVC();
	* // create the matrix containing the input features and the input vector for each matrix
	* var matrix &#x3D; new la.Matrix([[1, 0], [0, -1]]);
	* var vec &#x3D; new la.Vector([1, -1]);
	* // fit the model
	* SVC.fit(matrix, vec);
	* // create the vector you want to get the distance from the model
	* var vec2 &#x3D; new la.Vector([2, 3]);
	* // use the decisionFunction to get the distance of vec2 from the model
	* var distance &#x3D; SVC.decisionFunction(vec2); // returns something close to 5
	*/
 exports.SVC.prototype.decisionFunction &#x3D; function(X) { return (X instanceof require(&#x27;qminer&#x27;).la.Vector | X instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? 0 : Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
	* Sends vector through the model and returns the prediction as a real number.
    * @param {module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix} X - Input feature vector or matrix with feature vectors as columns.
    * @returns {number | module:la.Vector} Prediction:
	* &amp;lt;br&gt;1. Real number, if input is {@link module:la.Vector} or {@link module:la.SparseVector}.
	* &amp;lt;br&gt;2. {@link module:la.Vector}, if input is {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
	* &amp;lt;br&gt;1 for positive class and -1 for negative.
	* @example
	* // import the analytics and la modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new SVC object
	* var SVC &#x3D; new analytics.SVC();
	* // create the matrix containing the input features and the input vector for each matrix
	* var matrix &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	* var vec &#x3D; new la.Vector([1, 1, -1, -1]);
	* // fit the model
	* SVC.fit(matrix, vec);
	* // create a vector you want to predict 
	* var vec2 &#x3D; new la.Vector([3, 5]);
	* // predict the vector
	* var prediction &#x3D; SVC.predict(vec2); // returns 1
	*/
 exports.SVC.prototype.predict &#x3D; function(X) { return (X instanceof require(&#x27;qminer&#x27;).la.Vector | X instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? 0 : Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
	* Fits a SVM classification model, given column examples in a matrix and vector of targets.
	* @param {module:la.Matrix | module:la.SparseMatrix} X - Input feature matrix where columns correspond to feature vectors.
	* @param {module:la.Vector} y - Input vector of targets, one for each column of X.
	* @returns {module:analytics.SVC} Self.
	* @example
	* // import the analytics and la modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new SVC object
	* var SVC &#x3D; new analytics.SVC();
	* // create the matrix containing the input features and the input vector for each matrix.
	* var matrix &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	* var vec &#x3D; new la.Vector([1, 1, -1, -1]);
	* // fit the model
	* SVC.fit(matrix, vec); // creates a model, where the hyperplane has the normal semi-equal to [1, 1]
	*/
 exports.SVC.prototype.fit &#x3D; function(X, y) { return Object.create(require(&#x27;qminer&#x27;).analytics.SVC.prototype); }
/**
* SVR constructor parameters
* @typedef {Object} svrParam
* @property  {number} [svrParam.c&#x3D;1.0] - Cost parameter. Increasing the parameter forces the model to fit the training data more accurately (setting it too large may lead to overfitting).
* @property  {number} [svrParam.eps&#x3D;1e-1] - Epsilon insensitive loss parameter. Larger values result in fewer support vectors (smaller model complexity).
* @property  {number} [svrParam.batchSize&#x3D;1000] - Number of examples used in the subgradient estimation. Higher number of samples slows down the algorithm, but makes the local steps more accurate.
* @property  {number} [svrParam.maxIterations&#x3D;10000] - Maximum number of iterations.
* @property  {number} [svrParam.maxTime&#x3D;1.0] - Maximum runtime in seconds.
* @property  {number} [svrParam.minDiff&#x3D;1e-6] - Stopping criterion tolerance.
* @property  {boolean} [svrParam.verbose&#x3D;false] - Toggle verbose output in the console.
*/
/**
* SVR
* @classdesc Support Vector Machine Regression. Implements a soft margin linear support vector regression using the PEGASOS algorithm with epsilon insensitive loss, see: {@link http://ttic.uchicago.edu/~nati/Publications/PegasosMPB.pdf Pegasos: Primal Estimated sub-GrAdient SOlver for SVM}.
* @class
* @param {module:fs.FIn | module:analytics~svrParam} [arg] - File input stream (loads the model from disk) or constructor parameters svcParam.
* @example
* // import module
* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // REGRESSION WITH SVR
* // Set up fake train and test data.
* // Four training examples with, number of features &#x3D; 2
* var featureMatrix &#x3D; new la.Matrix({ rows: 2, cols: 4, random: true });
* // Regression targets for four examples
* var targets &#x3D; new la.Vector([1.1, -2, 3, 4.2]);
* // Set up the regression model
* var SVR &#x3D; new analytics.SVR({ verbose: false });
* // Train regression
* SVR.fit(featureMatrix, targets);
* // Set up a fake test vector
* var test &#x3D; new la.Vector([1.1, -0.8]);
* // Predict the target value
* var prediction &#x3D; SVR.predict(test);
*/
 exports.SVR &#x3D; function(arg) { return Object.create(require(&#x27;qminer&#x27;).analytics.SVR.prototype); };
/**
	* Returns the SVR parameters.
	* @returns {module:analytics~svrParam} Parameters of the regression model.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new SVR object
	* var SVR &#x3D; new analytics.SVR({ c: 10, eps: 1e-10, maxTime: 12000, verbose: true });
	* // get the parameters of SVR
	* var params &#x3D; SVR.getParams();
	*/
 exports.SVR.prototype.getParams &#x3D; function() { return { c: 0, eps: 0, batchSize: 0, maxIterations: 0, maxTime: 0, minDiff: 0, verbose: true } };
/**
	* Sets the SVR parameters.
	* @param {module:analytics~svrParam} param - Regression training parameters.
	* @returns {module:analytics.SVR} Self.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new SVR object
	* var SVR &#x3D; new analytics.SVR();
	* // set the parameters of the SVR object
	* SVR.setParams({ c: 10, maxTime: 12000 });
	*/
 exports.SVR.prototype.setParams &#x3D; function(param) { return Object.create(require(&#x27;qminer&#x27;).analytics.SVR.prototype); };
/**
	* The vector of coefficients of the linear model.
	* @returns {module:la.Vector} weights - Vector of coefficients of the linear model.
	*/
 exports.SVR.prototype.weights &#x3D; Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype);
/**
	* Saves model to output file stream.
	* @param {module:fs.FOut} fout - Output stream.
	* @returns {module:fs.FOut} Output stream.
	* @example
	* // import the modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	* // create a new SVR object
	* var SVR &#x3D; new analytics.SVR({ c: 10 });
	* // create a matrix and vector for the model
	* var matrix &#x3D; new la.Matrix([[1, -1], [1, 1]]);
	* var vector &#x3D; new la.Vector([1, 1]);
	* // create the model by fitting the values
	* SVR.fit(matrix, vector);
	* // save the model in a binary file
	* var fout &#x3D; fs.openWrite(&#x27;svr_example.bin&#x27;);
	* SVR.save(fout);
	* fout.close();
	* // construct a SVR model by loading from the binary file
	* var fin &#x3D; fs.openRead(&#x27;svr_example.bin&#x27;);
	* var SVR2 &#x3D; new analytics.SVR()
	*/
 exports.SVR.prototype.save &#x3D; function(fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
     * Sends vector through the model and returns the scalar product as a real number.
     * @param {module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix} X - Input feature vector or matrix with feature vectors as columns.
     * @returns {number | module:la.Vector} Distance:
	 * &amp;lt;br&gt;1. Real number if input is {@link module:la.Vector} or {@link module:la.SparseVector}.
	 * &amp;lt;br&gt;2. {@link module:la.Vector}, if input is {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
	 * @example
	 * // import the modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create a new SVR object
	 * var SVR &#x3D; new analytics.SVR({ c: 10 });
	 * // create a matrix and vector for the model
	 * var matrix &#x3D; new la.Matrix([[1, -1], [1, 1]]);
	 * var vector &#x3D; new la.Vector([1, 1]);
	 * // create the model by fitting the values
	 * SVR.fit(matrix, vector);
	 * // get the distance between the model and the given vector
	 * var vec2 &#x3D; new la.Vector([-5, 1]);
	 * var distance &#x3D; SVR.decisionFunction(vec2);
     */
 exports.SVR.prototype.decisionFunction &#x3D; function(X) { return (X instanceof require(&#x27;qminer&#x27;).la.Vector | X instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? 0 : Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
	* Sends vector through the model and returns the prediction as a real number.
    * @param {module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix} X - Input feature vector or matrix with feature vectors as columns.
    * @returns {number | module:la.Vector} Prediction:
	* &amp;lt;br&gt;1. Real number, if input is {@link module:la.Vector} or {@link module:la.SparseVector}.
	* &amp;lt;br&gt;2. {@link module:la.Vector}, if input is {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
	* @example
	* // import the modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new SVR object
	* var SVR &#x3D; new analytics.SVR({ c: 10 });
	* // create a matrix and vector for the model
	* var matrix &#x3D; new la.Matrix([[1, -1], [1, 1]]);
	* var vector &#x3D; new la.Vector([1, 1]);
	* // create the model by fitting the values
	* SVR.fit(matrix, vector);
	* // predict the value of the given vector
	* var vec2 &#x3D; new la.Vector([-5, 1]);
	* var prediction &#x3D; SVR.predict(vec2);
	*/
 exports.SVR.prototype.predict &#x3D; function(X) { return (X instanceof require(&#x27;qminer&#x27;).la.Vector | X instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? 0 : Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
	* fits an SVM regression model, given column examples in a matrix and vector of targets
	* @param {module:la.Matrix | module:la.SparseMatrix} X - Input feature matrix where columns correspond to feature vectors.
	* @param {module:la.Vector} y - Input vector of targets, one for each column of X.
	* @returns {module:analytics.SVR} Self.
	* @example
	* // import the modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new SVR object
	* var SVR &#x3D; new analytics.SVR({ c: 10 });
	* // create a matrix and vector for the model
	* var matrix &#x3D; new la.Matrix([[1, -1], [1, 1]]);
	* var vector &#x3D; new la.Vector([1, 1]);
	* // create the model by fitting the values
	* SVR.fit(matrix, vector);
	*/
 exports.SVR.prototype.fit &#x3D; function(X, y) { return Object.create(require(&#x27;qminer&#x27;).analytics.SVR.prototype); }
/**
* @typedef {Object} ridgeRegParam
* The Ridge Regression constructor parameter.
* @param {number} [gamma&#x3D;1.0] - The gamma value.
*/
/**
 * Ridge regression. Minimizes: ||A&#x27; x - b||^2 + ||gamma x||^2
 *
 * Uses {@link http://en.wikipedia.org/wiki/Tikhonov_regularization Tikhonov regularization}.
 *
 * @class
 * @param {(module:analytics~ridgeRegParam|module:fs.FIn)} [arg] - Loads a model from input stream, or creates a new model by setting gamma&#x3D;arg from a Json object.
 * Empty constructor sets gamma to zero.
 * @example
 * // import modules
 * la &#x3D; require(&#x27;qminer&#x27;).la;
 * analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
 * // create a new model with gamma &#x3D; 1.0
 * var regmod &#x3D; new analytics.RidgeReg({ gamma: 1.0 });
 * // generate a random feature matrix
 * var A &#x3D; la.randn(10,100);
 * // generate a random model
 * var w &#x3D; la.randn(10);
 * // generate noise
 * var n &#x3D; la.randn(100).multiply(0.01);
 * // generate responses (model&#x27;*data + noise)
 * var b &#x3D; A.transpose().multiply(w).plus(n);
 * // fit model
 * regmod.fit(A, b);
 * // compare
 * // true model
 * w.print();
 * // trained model&#x27;);
 * regmod.weights.print();
 * // cosine between the true and the estimated model should be close to 1 if the fit succeeded
 * var cos &#x3D; regmod.weights.cosine(w);
 */
 exports.RidgeReg &#x3D; function(arg) {};
/**
	* Gets the parameters.
	* @returns {Object} The Json object containing the parameters.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new Ridge Regression object
	* var regmod &#x3D; new analytics.RidgeReg({ gamma: 5 });
	* // get the parameters
	* // returns a json object { gamma: 5 }
	* var param &#x3D; regmod.getParams();
	*/
 exports.RidgeReg.prototype.getParams &#x3D; function () { return { gamma: 0.0 } }
/**
	* Set the parameters.
	* @param {(number|Object)} gamma - The new parameter for the model, given as a number or as a json object.
	* @returns {module:analytics.RidgeReg} Self. The parameter is set to gamma.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new Ridge Regression object
	* var regmod &#x3D; new analytics.RidgeReg({ gamma: 5 });
	* // set the parameters of the object
	* var param &#x3D; regmod.setParams({ gamma: 10 });
	*/
 exports.RidgeReg.prototype.setParams &#x3D; function (gamma) { return Object.create(require(&#x27;qminer&#x27;).analytics.RidgeReg.prototype); }
/**
     * Fits a column matrix of feature vectors X onto the response variable y.
     *
     * @param {module:la.Matrix} X - Column matrix which stores the feature vectors.
     * @param {module:la.Vector} y - Response variable.
     * @returns {module:analytics.RidgeReg} Self. The model is fitted by X and y.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create a new Ridge Regression object
	 * var regmod &#x3D; new analytics.RidgeReg();
	 * // create the test matrix and vector
	 * var X &#x3D; new la.Matrix([[1, 2], [1, -1]]);
	 * var y &#x3D; new la.Vector([3, 3]);
	 * // fit the model with X and y
	 * // the weights of the model are 2, 1
	 * regmod.fit(X, y);
     */
 exports.RidgeReg.prototype.fit &#x3D; function(X, y) { return Object.create(require(&#x27;qminer&#x27;).analytics.RidgeReg.prototype); }
/**
     * Returns the expected response for the provided feature vector.
     *
     * @param {module:la.Vector} x - Feature vector.
     * @returns {number} Predicted response.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create a new Ridge Regression object
	 * var regmod &#x3D; new analytics.RidgeReg();
	 * // create the test matrix and vector
	 * var X &#x3D; new la.Matrix([[1, 2], [1, -1]]);
	 * var y &#x3D; new la.Vector([3, 3]);
	 * // fit the model with X and y
	 * regmod.fit(X, y);
	 * // create a new vector for the prediction
	 * var vec &#x3D; new la.Vector([3, 4]);
	 * // create the prediction
	 * // returns the value 10
	 * var prediction &#x3D; regmod.decisionFunction(vec);
     */
 exports.RidgeReg.prototype.decisionFunction &#x3D; function(X) { return 0.0; }
/**
     * Returns the expected response for the provided feature vector.
     *
     * @param {module:la.Vector} x - Feature vector.
     * @returns {number} Predicted response.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create a new Ridge Regression object
	 * var regmod &#x3D; new analytics.RidgeReg();
	 * // create the test matrix and vector
	 * var X &#x3D; new la.Matrix([[1, 2], [1, -1]]);
	 * var y &#x3D; new la.Vector([3, 3]);
	 * // fit the model with X and y
	 * regmod.fit(X, y);
	 * // create a new vector for the prediction
	 * var vec &#x3D; new la.Vector([3, 4]);
	 * // create the prediction
	 * // returns the value 10
	 * var prediction &#x3D; regmod.predict(vec);
     */
 exports.RidgeReg.prototype.predict &#x3D; function(X) { return 0.0; }
/**
     * @property {module:la.Vector} weights - Vector of coefficients for linear regression.
     */
 exports.RidgeReg.prototype.weights &#x3D; Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype);
/**
     * Saves the model into the output stream.
     *
     * @param {module:fs.FOut} fout - Output stream.
	 * @returns {module:fs.FOut} THe output stream fout.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	 * // create a new Ridge Regression object
	 * var regmod &#x3D; new analytics.RidgeReg();
	 * // create the test matrix and vector
	 * var X &#x3D; new la.Matrix([[1, 2], [1, -1]]);
	 * var y &#x3D; new la.Vector([3, 3]);
	 * // fit the model with X and y
	 * regmod.fit(X, y);
	 * // create an output stream object and save the model
	 * var fout &#x3D; fs.openWrite(&#x27;regmod_example.bin&#x27;);
	 * regmod.save(fout);
	 * fout.close();
	 * // create a new Ridge Regression model by loading the model
	 * var fin &#x3D; fs.openRead(&#x27;regmod_example.bin&#x27;);
	 * var regmod2 &#x3D; new analytics.RidgeReg(fin);
     */
 exports.RidgeReg.prototype.save &#x3D; function(fout) { Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); };
/**
 * Sigmoid function (y &#x3D; 1/[1 + exp[-A*x + B]]) fitted on decision function to mimic.
 *
 * @class
 * @param {(null|module:fs.FIn)} [arg] - Loads a model from input stream, or creates a new model.
 * @example
 * // import modules
 * la &#x3D; require(&#x27;qminer&#x27;).la;
 * analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
 * // create a new model
 * var sigmoid &#x3D; new analytics.Sigmoid();
 * // generate a random predictions
 * var x &#x3D; new la.Vector([0.5, 2.3, -0.1, 0.5, -7.3, 1.2]);
 * // generate a random labels
 * var y &#x3D; new la.Vector([1, 1, -1, 1, -1, -1]);
 * // fit model
 * sigmoid.fit(x, y);
 * // get predictions
 * var pred1 &#x3D; sigmoid.predict(1.2);
 * var pred2 &#x3D; sigmoid.predict(-1.2);
 */
 exports.Sigmoid &#x3D; function(arg) {};
/**
	* Get the parameters. It doesn&#x27;t do anything, it&#x27;s only for consistency for constructing pipeline.
	* @returns {Object} The Json object containing parameters.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create the Sigmoid model
	* var s &#x3D; new analytics.Sigmoid();
	* // get the parameters
	* // returns an empty Json object
	* var param &#x3D; s.getParams();
	*/
 exports.Sigmoid.prototype.getParams &#x3D; function () { return {}; }
/**
	* Sets the parameters. It doesn&#x27;t do anything, it&#x27;s only for consistency for constructing pipeline.
	* @param {Object} arg - Json object. 
	* @returns {module:analytics.Sigmoid} Self.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create the Sigmoid model
	* var s &#x3D; new analytics.Sigmoid();
	* // set the parameters 
	* // doesn&#x27;t change the model
	* s.setParams({});
	*/
 exports.Sigmoid.prototype.setParams &#x3D; function (arg) { return Object.create(require(&#x27;qminer&#x27;).analytics.Sigmoid.prototype); }
/**
	* Gets the model.
	* @returns {Object} The Json object containing the A and B values of the Sigmoid.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create the Sigmoid model
	* var s &#x3D; new analytics.Sigmoid();
	* // get the model parameters
	* // returns a Json object { A: 0, B: 0 }
	* var model &#x3D; s.getModel();
	*/
 exports.Sigmoid.prototype.getModel &#x3D; function () {return { A: 0, B: 0 }; }
/**
     * Fits a column matrix of feature vectors X onto the response variable y.
     *
     * @param {module:la.Vector} x - Predicted values (e.g., using analytics.SVR)
     * @param {module:la.Vector} y - Actual binary labels: 1 or -1.
     * @returns {module:analytics.Sigmoid} Self.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create the Sigmoid model
	 * var s &#x3D; new analytics.Sigmoid();
	 * // create the predicted values and the binary labels
	 * var X &#x3D; new la.Vector([-3, -2, -1, 1, 2, 3]);
	 * var y &#x3D; new la.Vector([-1, -1, -1, 1, 1, 1]);
	 * // fit the model
	 * // changes the internal A and B values of the model 
	 * // (these values can be obtained with the getModel method)
	 * s.fit(X, y);
     */
 exports.Sigmoid.prototype.fit &#x3D; function(X, y) { return Object.create(require(&#x27;qminer&#x27;).analytics.Sigmoid.prototype); }
/**
     * Returns the expected response for the provided feature vector.
     *
     * @param {(number|module:la.Vector)} x - Prediction score (or vector of them).
     * @returns {(number|module:la.Vector)} Normalized prediction score (or vector of them).
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create the Sigmoid model
	 * var s &#x3D; new analytics.Sigmoid();
	 * // create the predicted values and the binary labels
	 * var X &#x3D; new la.Vector([-3, -2, -1, 1, 2, 3]);
	 * var y &#x3D; new la.Vector([-1, -1, -1, 1, 1, 1]);
	 * // fit the model
	 * s.fit(X, y);
	 * // predict the probability of the value 0 on this model
	 * // returns 0.5
	 * var prediction &#x3D; s.decisionFunction(0.5);
     */
 exports.Sigmoid.prototype.decisionFunction &#x3D; function(x) { return (x instanceof la.Vector) ? Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype) : 0.0; }
/**
     * Returns the expected response for the provided feature vector.
     *
     * @param {(number|module:la.Vector)} x - Prediction score (or vector of them).
     * @returns {(number|module:la.Vector)} Normalized prediction score (or vector of them).
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create the Sigmoid model
	 * var s &#x3D; new analytics.Sigmoid();
	 * // create the predicted values and the binary labels
	 * var X &#x3D; new la.Vector([-3, -2, -1, 1, 2, 3]);
	 * var y &#x3D; new la.Vector([-1, -1, -1, 1, 1, 1]);
	 * // fit the model
	 * s.fit(X, y);
	 * // predict the probability of the value 0 on this model
	 * // returns 0.5
	 * var prediction &#x3D; s.predict(0.5);
     */
 exports.Sigmoid.prototype.predict &#x3D; function(x) { return (x instanceof la.Vector) ? Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype) : 0.0; }
/**
     * Saves the model into the output stream.
     *
     * @param {module:fs.FOut} fout - Output stream.
	 * @returns {module:fs.FOut} The output stream fout.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	 * // create the Sigmoid model
	 * var s &#x3D; new analytics.Sigmoid();
	 * // create the predicted values and the binary labels
	 * var X &#x3D; new la.Vector([-3, -2, -1, 1, 2, 3]);
	 * var y &#x3D; new la.Vector([-1, -1, -1, 1, 1, 1]);
	 * // fit the model
	 * s.fit(X, y);
	 * // create an output stream object and save the model
	 * var fout &#x3D; fs.openWrite(&#x27;sigmoid_example.bin&#x27;);
	 * s.save(fout);
	 * fout.close();
	 * // create a new Sigmoid model by loading the model
	 * var fin &#x3D; fs.openRead(&#x27;sigmoid_example.bin&#x27;);
	 * var s2 &#x3D; new analytics.Sigmoid(fin);
     */
 exports.Sigmoid.prototype.save &#x3D; function(fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); };
/**
* @typedef {Object} detectorParam
* A Json object used for the creation of the {@link module:analytics.NearestNeighborAD}.
* @param {number} [rate&#x3D;0.05] - The expected fracton of emmited anomalies (0.05 -&gt; 5% of cases will be classified as anomalies).
* @param {number} [windowSize&#x3D;100] - Number of most recent instances kept in the model.
*/
/**
 * Nearest Neighbour Anomaly Detection 
 * @classdesc Anomaly detector that checks if the test point is too far from the nearest known point.
 * @class
 * @param {(module:analytics~detectorParam|module:fs.FIn)} [detectorParam] - Constructor parameters.
 * @example
 * // import modules
 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
 * var la &#x3D; require(&#x27;qminer&#x27;).la;
 * // create a new NearestNeighborAD object
 * var neighbor &#x3D; new analytics.NearestNeighborAD({ rate: 0.1 });
 * // create a sparse matrix 
 * var matrix &#x3D; new la.SparseMatrix([[[0, 1], [1, 2]], [[0, -2], [1, 3]], [[0, 0], [1, 1]]]);
 * // fit the model with the matrix
 * neighbor.fit(matrix);
 * // create a new sparse vector
 * var vector &#x3D; new la.SparseVector([[0, 4], [1, 0]]);
 * // predict if the vector is an anomaly or not
 * var prediction &#x3D; neighbor.predict(vector);
 */
 exports.NearestNeighborAD &#x3D; function(arg) { return Object.create(require(&#x27;qminer&#x27;).analytics.NearestNeighborAD.prototype); };
/**
	* Sets parameters.
	* @param {module:analytics~detectorParam} newParams - The Json object containing the new rate value.
	* @returns {module:analytics.NearestNeighborAD} Self. The parameters are updated with newParams.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new NearestNeighborAD object
	* var neighbor &#x3D; new analytics.NearestNeighborAD();
	* // set it&#x27;s parameters to rate: 0.1
	* neighbor.setParams({ rate: 0.1 });
	*/
 exports.NearestNeighborAD.prototype.setParams &#x3D; function (newParams) { return Object.create(require(&#x27;qminer&#x27;).analytics.NearestNeighborAD.prototype); }
/**
	* Returns parameters.
	* @returns {module:analytics~detectorParam} The Json object containing the rate value.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new NearestNeighborAD object
	* var neighbor &#x3D; new analytics.NearestNeighborAD();
	* // get the parameters of the object
	* // returns a json object { rate: 0.05 }
	* var params &#x3D; neighbor.getParams();
	*/
 exports.NearestNeighborAD.prototype.getParams &#x3D; function () { return { rate: 0.0, windowSize: 0.0 }; }
/**
     * Save model to provided output stream.
     * @param {module:fs.FOut} fout - The output stream.
     * @returns {module:fs.FOut} Provided output stream fout.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	 * // create a new NearestNeighborAD object
	 * var neighbor &#x3D; new analytics.NearestNeighborAD();
	 * // create a new sparse matrix
	 * var matrix &#x3D; new la.SparseMatrix([[[0, 1], [1, 2]], [[0, -2], [1, 3]], [[0, 0], [1, 1]]]);
	 * // fit the model with the matrix
	 * neighbor.fit(matrix);
	 * // create an output stream object and save the model
	 * var fout &#x3D; fs.openWrite(&#x27;neighbor_example.bin&#x27;);
	 * neighbor.save(fout);
	 * fout.close();
	 * // create a new Nearest Neighbor Anomaly model by loading the model
	 * var fin &#x3D; fs.openRead(&#x27;neighbor_example.bin&#x27;);
	 * var neighbor2 &#x3D; new analytics.NearestNeighborAD(fin);
     */
 exports.NearestNeighborAD.prototype.save &#x3D; function(fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
	* Returns the model.
	* @returns {Object} Json object whose keys are:
	* &amp;lt;br&gt; 1. rate - The expected fraction of emmited anomalies.
	* &amp;lt;br&gt; 2. thresh - Maximal squared distance to the nearest neighbor that is not anomalous.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new NearestNeighborAD object
	* var neighbor &#x3D; new analytics.NearestNeighborAD({ rate: 0.1 });
	* // get the model of the object
	* // returns a json object { rate: 0.1, window: 0 }
	* var model &#x3D; neighbor.getModel();
	*/
 exports.NearestNeighborAD.prototype.getModel &#x3D; function () { return { threshold: 0.0 }; }
/**
	* Adds a new point to the known points and recomputes the threshold.
	* @param {module:la.SparseVector} X - Test example (vector input)
	* @param {number} recId - Integer record ID, used in NearestNeighborAD.explain
	* @returns {module:analytics.NearestNeighborAD} Self. The model is updated.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new NearestNeighborAD object
	* var neighbor &#x3D; new analytics.NearestNeighborAD();
	* // create a new sparse matrix
	* var matrix &#x3D; new la.SparseMatrix([[[0, 1], [1, 2]], [[0, -2], [1, 3]], [[0, 0], [1, 1]]]);
	* // fit the model with the matrix
	* neighbor.fit(matrix);
	* // create a new sparse vector
	* var vector &#x3D; new la.SparseVector([[0, 2], [1, 5]]);
	* // update the model with the vector
	* neighbor.partialFit(vector);
	*/
 exports.NearestNeighborAD.prototype.partialFit &#x3D; function(X) { return Object.create(require(&#x27;qminer&#x27;).NearestNeighborAD.prototype); }
/**
	* Analyzes the nearest neighbor distances and computes the detector threshold based on the rate parameter.
	* @param {module:la.SparseMatrix} A - Matrix whose columns correspond to known examples. Gets saved as it is part of
	* @param {module:la.IntVector} [idVec] - An integer vector of IDs
	* the model.
	* @returns {module:analytics.NearestNeighborAD} Self. The model is set by the matrix A.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new NearestNeighborAD object
	* var neighbor &#x3D; new analytics.NearestNeighborAD();
	* // create a new sparse matrix
	* var matrix &#x3D; new la.SparseMatrix([[[0, 1], [1, 2]], [[0, -2], [1, 3]], [[0, 0], [1, 1]]]);
	* // fit the model with the matrix
	* neighbor.fit(matrix);
	*/
 exports.NearestNeighborAD.prototype.fit &#x3D; function(A, idVec) { return Object.create(require(&#x27;qminer&#x27;).NearestNeighborAD.prototype); }
/**
     * Compares the point to the known points and returns distance to the nearest one.
     * @param {module:la.Vector} x - Test vector.
     * @returns {number} Distance to the nearest point.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create a new NearestNeighborAD object
	 * var neighbor &#x3D; new analytics.NearestNeighborAD();
	 * // create a new sparse matrix
	 * var matrix &#x3D; new la.SparseMatrix([[[0, 1], [1, 2]], [[0, -2], [1, 3]], [[0, 0], [1, 1]]]);
	 * // fit the model with the matrix
	 * neighbor.fit(matrix);
	 * // create a new sparse vector
	 * var vector &#x3D; new la.SparseVector([[0, 4], [1, 0]]);
	 * // get the distance of the vector from the model
	 * var prediction &#x3D; neighbor.decisionFunction(vector); // returns 1
	 */
 exports.NearestNeighborAD.prototype.decisionFunction &#x3D; function(x) { return 0.0; }
/**
	* Compares the point to the known points and returns 1 if it&#x27;s too far away (based on the precomputed threshold).
	* @param {module:la.SparseVector} x - Test vector.
	* @returns {number} Returns 1.0 if the vector x is an anomaly and 0.0 otherwise.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new NearestNeighborAD object
	* var neighbor &#x3D; new analytics.NearestNeighborAD();
	* // create a new sparse matrix
	* var matrix &#x3D; new la.SparseMatrix([[[0, 1], [1, 2]], [[0, -2], [1, 3]], [[0, 0], [1, 1]]]);
	* // fit the model with the matrix
	* neighbor.fit(matrix);
	* // create a new sparse vector
	* var vector &#x3D; new la.SparseVector([[0, 4], [1, 0]]);
	* // check if the vector is an anomaly
	* var prediction &#x3D; neighbor.predict(vector); // returns 1
	*/
 exports.NearestNeighborAD.prototype.predict &#x3D; function(x) { return 0.0; }
/**
	* @typedef {Object} NearestNeighborADExplain
	* A Json object used for interpreting the predictions of {@link module:analytics.NearestNeighborAD}.
	* @param {number} nearestID - The ID of the nearest neighbor
	* @param {Array&amp;lt;number&gt;} featureIDs - the IDs of the features that contributed to the distance score
	* @param {Array&amp;lt;number&gt;} featureContributions - fractions of the contributions of each feature to the total distance (the scores sum to 1.0). The elements correspond to features in the array &#x60;featureIDs&#x60;
	*/
/**
	* Returns a JSON object that encodes the ID of the nearest neighbor and the features that contributed to the distance
	* @param {module:la.SparseVector} x - Test vector.
	* @returns {module:analytics~NearestNeighborADExplain} The explanation object
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new NearestNeighborAD object
	* var neighbor &#x3D; new analytics.NearestNeighborAD({rate:0.05, windowSize:3});
	* // create a new sparse matrix
	* var matrix &#x3D; new la.SparseMatrix([[[0, 1], [1, 2]], [[0, -2], [1, 3]], [[0, 0], [1, 1]]]);
	* // fit the model with the matrix and provide a vector record IDs
	* neighbor.fit(matrix, new la.IntVector([3541,1112,4244]));
	* // create a new sparse vector
	* var vector &#x3D; new la.SparseVector([[0, 4], [1, 0]]);
	* // check if the vector is an anomaly
	* var explanation &#x3D; neighbor.explain(vector); // returns an explanation
	*/
 exports.NearestNeighborAD.prototype.explain &#x3D; function(x) { return {}; }
/**
* @typedef {Object} recLinearRegParam
* The constructor parameter for {@link module:analytics.RecLinReg}.
* @param {number} dim - The dimension of the model.
* @param {number} [regFact&#x3D;1.0] - The regularization factor.
* @param {number} [forgetFact&#x3D;1.0] - The forgetting factor.
*/
/**
* Recursive Linear Regression
* @classdesc Holds the Recursive Linear Regression model.
* @class
* @param {(module:analytics~recLinearRegParam|module:fs.FIn)} param - The constructor parameter json object.
* @example
* // import analytics module
* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
* // create the recursive linear regression model holder
* var linreg &#x3D; new analytics.RecLinReg({ dim: 10, regFact: 1.0, forgetFact: 1.0 });
*/
 exports.RecLinReg &#x3D; function(param) { return Object.create(require(&#x27;qminer&#x27;).analytics.RecLinReg.prototype); }
/**
	* Creates a partial fit of the input.
	* @param {module:la.Vector} vec - The input vector.
	* @param {number} num - The target number for the vector.
	* @returns {module:analytics.RecLinReg} Self. The internal model is updated.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create the Recursive Linear Regression model
	* var linreg &#x3D; new analytics.RecLinReg({ dim: 3.0 });
	* // create a new dense vector
	* var vec &#x3D; new la.Vector([1, 2, 3]);
	* // fit the model with the vector
	* linreg.partialFit(vec, 6);
	*/
 exports.RecLinReg.prototype.partialFit &#x3D; function (vec, num) { return Object.create(require(&#x27;qminer&#x27;).analytics.RecLinReg.prototype); }
/**
	* Creates a fit of the input.
	* @param {module:la.Matrix} mat - The input matrix.
	* @param {module:la.Vector} vec - The target numbers, where the i-th number in vector is the target number for the i-th column of the matrix.
	* @returns {module:analytics.RecLinReg} Self. The internal model is updated.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create the Recursive Linear Regression model
	* var linreg &#x3D; new analytics.RecLinReg({ dim: 2.0 });
	* // create a new dense matrix and target vector
	* var mat &#x3D; new la.Matrix([[1, 2, 3], [3, 4, 5]]);
	* var vec &#x3D; new la.Vector([3, 5, -1]);
	* // fit the model with the matrix
	* linreg.fit(mat, vec);
	*/
 exports.RecLinReg.prototype.fit &#x3D; function (mat, vec) { return Object.create(require(&#x27;qminer&#x27;).analytics.RecLinReg.prototype); }
/**
	* Puts the vector through the model and returns the prediction as a real number.
	* @param {module:la.Vector} vec - The vector needed to be predicted.
	* @returns {number} The prediction.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create the Recursive Linear Regression model
	* var linreg &#x3D; new analytics.RecLinReg({ dim: 2.0, recFact: 1e-10 });
	* // create a new dense matrix and target vector
	* var mat &#x3D; new la.Matrix([[1, 2], [1, -1]]);
	* var vec &#x3D; new la.Vector([3, 3]);
	* // fit the model with the matrix
	* linreg.fit(mat, vec);
	* // create the vector to be predicted
	* var pred &#x3D; new la.Vector([1, 1]);
	* // predict the value of the vector
	* var prediction &#x3D; linreg.predict(pred); // returns something close to 3.0
	*/
 exports.RecLinReg.prototype.predict &#x3D; function (vec) { return 0.0 }  
/**
	* Sets the parameters of the model.
	* @param {module:analytics~recLinearRegParam} param - The new parameters of the model.
	* @returns {module:analytics.RecLinReg} Self. The parameters are updated. Any previous model is set to default.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new Recursive Linear Regression model
	* var linreg &#x3D; new analytics.RecLinReg({ dim: 10 });
	* // set the parameters of the model
	* linreg.setParams({ dim: 3, recFact: 1e2, forgetFact: 0.5 });
	*/
 exports.RecLinReg.prototype.setParams &#x3D; function (param) { return Object.create(require(&#x27;qminer&#x27;).analytics.RecLinReg.prototype); }
/**
	* Returns the parameters.
	* @returns {module:analytics~recLinearRegParam} The parameters of the model.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a new Recursive Linear Regression model
	* var linreg &#x3D; new analytics.RecLinReg({ dim: 10 });
	* // get the parameters of the model
	* var params &#x3D; linreg.getParams(); // returns { dim: 10, recFact: 1.0, forgetFact: 1.0 }
	*/
 exports.RecLinReg.prototype.getParams &#x3D; function () { return { dim: 0, regFact: 1.0, forgetFact: 1.0 }}
/**
	* Gives the weights of the model.
	*/
 exports.RecLinReg.prototype.weights &#x3D; Object.create(require(&#x27;qminer&#x27;).la.Vector);
/**
	* Gets the dimensionality of the model.
	*/
 exports.RecLinReg.prototype.dim &#x3D; 0;
/**
	* Save model to provided output stream.
	* @param {module:fs.FOut} fout - The output stream.
	* @returns {module:fs.FOut} Provided output stream fout.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	* // create the Recursive Linear Regression model
	* var linreg &#x3D; new analytics.RecLinReg({ dim: 2.0, recFact: 1e-10 });
	* // create a new dense matrix and target vector
	* var mat &#x3D; new la.Matrix([[1, 2], [1, -1]]);
	* var vec &#x3D; new la.Vector([3, 3]);
	* // fit the model with the matrix
	* linreg.fit(mat, vec);
	* // create an output stream object and save the model
	* var fout &#x3D; fs.openWrite(&#x27;linreg_example.bin&#x27;);
	* linreg.save(fout);
	* fout.close();
	* // create a new Nearest Neighbor Anomaly model by loading the model
	* var fin &#x3D; fs.openRead(&#x27;linreg_example.bin&#x27;);
	* var linreg2 &#x3D; new analytics.RecLinReg(fin);
	*/
 exports.RecLinReg.prototype.save &#x3D; function(fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
* @typedef {Object} logisticRegParam
* The Json constructor parameters for {@link module:analytics.LogReg}.
* @property {number} [lambda&#x3D;1] - The regularization parameter.
* @property {boolean} [intercept&#x3D;false] - Indicates wether to automatically include the intercept.
*/
/**
 * Logistic regression model. Uses Newtons method to compute the weights.
 * &amp;lt;b&gt;Before use: include BLAS library.&amp;lt;/b&gt;
 * @constructor
 * @param {(module:analytics~logisticRegParam|module:fs.FIn)} [opts] - The options used for initialization or the input stream from which the model is loaded. If this parameter is an input stream than no other parameters are required.
 * @example
 * // import analytics module
 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
 * // create the Logistic Regression model
 * var logreg &#x3D; new analytics.LogReg({ lambda: 2 });
 */
 exports.LogReg &#x3D; function (opts) { return Object.create(require(&#x27;qminer&#x27;).analytics.LogReg.prototype); }
/**
	* Gets the parameters.
	* @returns {module:analytics~logisticRegParam} The parameters of the model.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create the Logistic Regression model
	* var logreg &#x3D; new analytics.LogReg({ lambda: 10 });
	* // get the parameters of the model
	* var param &#x3D; logreg.getParams(); // returns { lambda: 10, intercept: false }
	*/
 exports.LogReg.prototype.getParams &#x3D; function () { return { lambda: 1.0, intercept: false } };
/**
	* Set the parameters.
	* @param {module:analytics~logisticRegParam} param - The new parameters.
	* @returns {module:analytics.LogReg} Self. The parameters are updated.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a logistic regression model
	* var logreg &#x3D; new analytics.LogReg({ lambda: 10 });
	* // set the parameters of the model
	* logreg.setParams({ lambda: 1 });
	*/
 exports.LogReg.prototype.setParams &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).analytics.LogReg.prototype); }
/**
	 * Fits a column matrix of feature vectors X onto the response variable y.
	 * @param {module:la.Matrix} X - the column matrix which stores the feature vectors.
	 * @param {module:la.Vector} y - the response variable.
	 * @param {number} [eps] - the epsilon used for convergence.
	 * @returns {module:analytics.LogReg} Self.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create the logistic regression model
	 * var logreg &#x3D; new analytics.LogReg();
	 * // create the input matrix and vector for fitting the model
	 * var mat &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	 * var vec &#x3D; new la.Vector([1, 0, -1, -2]);
	 * // if openblas is used, fit the model
	 * if (require(&#x27;qminer&#x27;).flags.blas) {
	 *     logreg.fit(mat, vec);
	 * }
	 */
 exports.LogReg.prototype.fit &#x3D; function (X, y, eps) { return Object.create(require(&#x27;qminer&#x27;).analytics.LogReg.prototype); }
/**
	 * Returns the expected response for the provided feature vector.
	 * @param {module:la.Vector} x - the feature vector.
	 * @returns {number} the expected response.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create the logistic regression model
	 * var logreg &#x3D; new analytics.LogReg();
	 * // create the input matrix and vector for fitting the model
	 * var mat &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	 * var vec &#x3D; new la.Vector([1, 0, -1, -2]);
	 * // if openblas is used
	 * if (require(&#x27;qminer&#x27;).flags.blas) {
	 *     // fit the model
	 *     logreg.fit(mat, vec);
	 *     // create the vector for the prediction
	 *     var test &#x3D; new la.Vector([1, 1]);
	 *     // get the prediction
	 *     var prediction &#x3D; logreg.predict(test);
	 * };
	 */
 exports.LogReg.prototype.predict &#x3D; function (x) { return 0.0; } 
/**
	 * Gives the weights of the model.
	 */
 exports.LogReg.prototype.weights &#x3D; Object.create(require(&#x27;qminer&#x27;).la.vector.prototype);
/**
	 * Saves the model into the output stream.
	 * @param {module:fs.FOut} fout - the output stream.
	 * @returns {module:fs.FOut} The output stream fout.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	 * // create the logistic regression model
	 * var logreg &#x3D; new analytics.LogReg();
	 * // create the input matrix and vector for fitting the model
	 * var mat &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	 * var vec &#x3D; new la.Vector([1, 0, -1, -2]);
	 * // if openblas is used, fit the model
	 * if (require(&#x27;qminer&#x27;).flags.blas) {
	 *     logreg.fit(mat, vec);
	 * };
	 * // create an output stream object and save the model
	 * var fout &#x3D; fs.openWrite(&#x27;logreg_example.bin&#x27;);
	 * logreg.save(fout);
	 * fout.close();
	 * // create input stream
	 * var fin &#x3D; fs.openRead(&#x27;logreg_example.bin&#x27;);
	 * // create a Logistic Regression object that loads the model and parameters from input stream
	 * var logreg2 &#x3D; new analytics.LogReg(fin);
	 */
 exports.LogReg.prototype.save &#x3D; function (fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
* @typedef {Object} hazardModelParam
* The constructor parameters for the Proportional Hazards Model.
* @property {number} [lambda &#x3D; 0] - The regularization parameter.
*/
/**
 * Proportional Hazards Model with a constant hazard function.
 * Uses Newtons method to compute the weights.
 * &amp;lt;b&gt;Before use: include BLAS library.&amp;lt;/b&gt;
 *
 * @constructor
 * @property {module:analytics~hazardModelParam|module:fs.FIn} [opts] - The options used for initialization or the input stream from which the model is loaded. If this parameter is an input stream than no other parameters are required.
 * @example
 * // import analytics module
 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
 * // create a Proportional Hazard model
 * var hazard &#x3D; new analytics.PropHazards();
 */
 exports.PropHazards &#x3D; function (opts) { return Object.create(require(&#x27;qminer&#x27;).analytics.PropHazards.prototype); }
/**
	* Gets the parameters of the model.
	* @returns {module:analytics~hazardModelParam} The parameters of the model.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a Proportional Hazard model
	* var hazard &#x3D; new analytics.PropHazards({ lambda: 5 });
	* // get the parameters of the model
	* var param &#x3D; hazard.getParams();
	*/
 exports.PropHazards.prototype.getParams &#x3D; function () { return { lambda: 0.0 }; }
/**
	* Sets the parameters of the model.
	* @param {module:analytics~hazardModelParam} params - The parameters given to the model.
	* @returns {module:analytics.PropHazards} Self.
	* @example 
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a Proportional Hazard model
	* var hazard &#x3D; new analytics.PropHazards({ lambda: 5 });
	* // set the parameters of the model
	* hazard.setParams({ lambda: 10 });
	*/
 exports.PropHazards.prototype.setParams &#x3D; function (params) { return Object.create(require(&#x27;qminer&#x27;).analytics.PropHazards.prototype); }
/**
	 * Fits a column matrix of feature vectors X onto the response variable y.
	 *
	 * @param {module:la.Matrix} X - The column matrix which stores the feature vectors.
	 * @param {module:la.Vector} y - The response variable.
	 * @param {number} [eps] - The epsilon used for convergence.
	 * @returns {module:analytics.PropHazards} Self.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create the Proportional Hazards model
	 * var hazards &#x3D; new analytics.PropHazards();
	 * // create the input matrix and vector for fitting the model
	 * var mat &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	 * var vec &#x3D; new la.Vector([1, 0, -1, -2]);
	 * // if openblas used, fit the model
	 * if (require(&#x27;qminer&#x27;).flags.blas) {
	 *     hazards.fit(mat, vec);
	 * };
	 */
 exports.PropHazards.prototype.fit &#x3D; function(X, y, eps) { return Object.create(require(&#x27;qminer&#x27;).analytics.PropHazards.prototype); }
/**
	 * Returns the expected response for the provided feature vector.
	 *
	 * @param {module:la.Vector} x - The feature vector.
	 * @returns {number} The expected response.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * // create the Proportional Hazards model
	 * var hazards &#x3D; new analytics.PropHazards();
	 * // create the input matrix and vector for fitting the model
	 * var mat &#x3D; new la.Matrix([[1, 1], [1, -1]]);
     * var vec &#x3D; new la.Vector([3, 3]);
	 * // if openblas used
	 * if (require(&#x27;qminer&#x27;).flags.blas) {
	 *     // fit the model
	 *     hazards.fit(mat, vec);       
	 *     // create a vector for the prediction
	 *      var test &#x3D; new la.Vector([1, 2]);
	 *     // predict the value
	 *     var prediction &#x3D; hazards.predict(test);
	 * };
	 */
 exports.PropHazards.prototype.predict &#x3D; function(x) { return 0.0; }
/**
	 * The models weights.
	 */
 exports.PropHazards.prototype.weights &#x3D; Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype);
/**
	 * Saves the model into the output stream.
	 * @param {module:fs.FOut} sout - The output stream.
	 * @returns {module:fs.FOut} The output stream sout.
	 * @example
	 * // import modules
	 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	 * var la &#x3D; require(&#x27;qminer&#x27;).la;
	 * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	 * // create the Proportional Hazards model
	 * var hazards &#x3D; new analytics.PropHazards();
	 * // create the input matrix and vector for fitting the model
	 * var mat &#x3D; new la.Matrix([[1, 0, -1, 0], [0, 1, 0, -1]]);
	 * var vec &#x3D; new la.Vector([1, 0, -1, -2]);
	 * // if openblas used, fit the model
	 * if (require(&#x27;qminer&#x27;).flags.blas) {
	 *     hazards.fit(mat, vec);
	 * };
	 * // create an output stream and save the model
	 * var fout &#x3D; fs.openWrite(&#x27;hazards_example.bin&#x27;);
	 * hazards.save(fout);
	 * fout.close();
	 * // create input stream
	 * var fin &#x3D; fs.openRead(&#x27;hazards_example.bin&#x27;);
	 * // create a Proportional Hazards object that loads the model and parameters from input stream
	 * var hazards2 &#x3D; new analytics.PropHazards(fin);	
	 */
 exports.PropHazards.prototype.save &#x3D; function(sout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
	 * Returns the probability distribution over the future states given that the current state is the one in
	 * the parameter.
	 *
	 * @param {Number} level - the level on which we want the future states
	 * @param {Number} startState - the ID of the current state (the state we are starting from)
	 * @param {Number} [time] - optional parameter, if not specified the distribution of the next state will be returned
	 * @returns {Array} - the probability distribution
	 */
/**
	 * Returns the probability distribution over the past states given that the current state is the one in
	 * the parameter.
	 *
	 * @param {Number} level - the level on which we want the past states
	 * @param {Number} startState - the ID of the current state (the state we are starting from)
	 * @param {Number} [time] - optional parameter, if not specified the distribution of the previous state will be returned
	 * @returns {Array} - the probability distribution
	 */
/**
	 * Returns the probability distribution of past and future states over time.
	 *
	 * @param {Number} stateId - ID if the starting state
	 * @param {Number} height - the hieght
	 * @param {Number} time - the time at which we want the probabilities
	 * @returns {Array} - array of state ids and their probabilities
	 */
/**
	 * Returns information about previous states.
	 *
	 * @param {Number} level - the level on which we want the past states
	 * @retuns {Array} - information about the past states
	 */
/**
	 * Returns an object representation of this model.
	 *
	 * @returns {Object}
	 */
/**
	 * Returns the underlying transition model at the lowest level. (for CTMC the matrix of intensities)
	 *
	 * @returns {Array} - the transition model
	 */
/**
	 * Returns the current state throughout the hierarchy. If the level is specified it
	 * will return the current state only on that level.
	 *
	 * @param {Number} [level] - optional level parameter
	 * @returns {Array|Number} - if the level is specified it returns info about the current state on that level, otherwise it return info about the current state on each level on the hierarchy
	 */
/**
	 * Returns the centroid of the specified state containing only the observation parameters.
	 *
	 * @param {Number} stateId - the ID of the state
	 * @param {Boolean} [observations&#x3D;true] - indicates wether to output observation or control coordinates
	 * @returns {Array} - the coordinates of the state
	 */
/**
	 * Returns a histogram of the specified feature in the specified state.
	 *
	 * @param {Number} stateId - the ID of the state
	 * @param {Number} ftrId - the ID of the feature
	 * @returns {Array} - the histogram
	 */
/**
	 * Returns the lower and upper bound of the feature.
	 *
	 * @param {Integer} ftrId - id of the feature
	 */
/**
	 * Returns an array of IDs of all the states on the specified height.
	 *
	 * @param {Number} height - the height
	 * @returns {Array} - the array of IDs
	 */
/**
	 * Returns the weights of features in this state.
	 *
	 * @param {Number} stateId - The Id of the state.
	 * @returns {Array} - An array of weights.
	 */
/**
	 * Returns a JSON representation of a decision tree, which classifies
	 * this state against other states
	 *
	 * @param {Number} stateId
	 * @returns {Object}
	 */
/**
	 * Sets a callback function which is fired when the model changes states. An array of current states
	 * throughout the hierarchy is passed to the callback.
	 *
	 * @param {function} callback - the funciton which is called
	 */
/**
	 * Sets a callback function which is fired when the model detects an anomaly. A string description is
	 * passed to the callback.
	 *
	 * @param {function} callback - the funciton which is called
	 */
/**
	 * Sets a callback function which is fired when the model detects an outlier. A string description is
	 * passed to the callback.
	 *
	 * @param {function} callback - the funciton which is called
	 */
/**
	 * Sets a callback function which is fired when a prediction is made. 4 paramters are passed
	 * to the callback:
	 * - Id of the target state
	 * - probability of occurring
	 * - vector of probabilities
	 * - vector of times corresponding to those probabilities
	 *
	 * @param {function} callback - the funciton which is called
	 */
/**
	 * Rebuilds its hierarchy.
	 */
/**
	 * Rebuilds the histograms using the instances stored in the columns of X.
	 *
	 * @param {Matrix} obsMat - the column matrix containing observation data instances
	 * @param {Matrix} controlMat - the column matrix containing control data instances
	 */
/**
	 * Returns the name of a state.
	 *
	 * @param {Number} stateId - ID of the state
	 * @returns {String} - the name of the state
	 */
/**
	 * Sets the name of the state.
	 *
	 * @param {Number} stateId - ID of the state
	 * @param {String} name - name of the state
	 */
/**
	 * Sets the name of the state.
	 *
	 * @param {Number} stateId - ID of the state
	 */
/**
	 * Returns true if the state is a target on the specified height.
	 *
	 * @param {Number} stateId - Id of the state
	 * @param {Number} height - the height
	 * @returns {Boolean}
	 */
/**
	 * Sets whether the specified state is a target state or not.
	 *
	 * @param {Number} stateId - ID of the state
	 * @param {Number} height - the height on which the state is a target
	 * @param {Boolean} isTarget - set target on/off
	 */
/**
	 * Returns true if the state defined by the ID is at the bottom of the hierarchy.
	 *
	 * @param {Number} stateId - ID of the state
	 */
/**
	 * Returns the time unit used by this model.
	 *
	 * @returns {String} timeUnit
	 */
/**
	 * Sets the factor of the specified control:
	 *
	 * @param {Object} params - the parameters
	 * @property {Number} [params.stateId] - id of the state, if not present, all the states will be set
	 * @property {Number} params.ftrId - the index of the control feature
	 * @property {Number} params.val - the value of the featuere
	 */
/**
	 * Returns true is any of the control parameters have been set in any of the states.
	 *
	 * @returns {Boolean}
	 */
/**
	 * Saves the model to the output stream.
	 *
	 * @param {FOut} fout - the output stream
	 */
/**
* @typedef {Object} nnetParams
* @property {module:la.IntVector} [layout] - The integer vector with the corresponding values of the number of neutrons. Default is the integer vector [1, 2 ,1].
* @property {number} [learnRate &#x3D; 0.1] - The learning rate.
* @property {number} [momentum &#x3D; 0.5] - The momentum of optimization.
* @property {string} [tFuncHidden &#x3D; &#x27;tanHyper&#x27;] - The function.
* @property {string} [tFuncOut &#x3D; &#x27;tanHyper&#x27;] - The function.
*/
/**
* Neural Network Model
* @classdesc Holds online/offline neural network model.
* @class
* @param {module:analytics~nnetParams|module:fs.FIn} [params] - The parameters for the construction of the model.
*/
 exports.NNet &#x3D; function (params) { return Object.create(require(&#x27;qminer&#x27;).analytics.NNet.prototype); }
/**
	* Get the parameters of the model.
	* @returns {module:analytics~nnetParams} The constructor parameters.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a Neural Networks model
	* var nnet &#x3D; new analytics.NNet();
	* // get the parameters
	* var params &#x3D; nnet.getParams();
	*/
 exports.NNet.prototype.getParams &#x3D; function () { return { layout: Object.create(require(&#x27;qminer&#x27;).la.IntVector.prototype), learnRate: 0.0, momentum: 0.0, tFuncHidden: &quot;&quot;, TFuncOut: &quot;&quot; }; }
/**
	* Sets the parameters of the model.
	* @params {module:analytics~nnetParams} params - The given parameters.
	* @returns {module:analytics.NNet} Self.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a Neural Networks model
	* var nnet &#x3D; new analytics.NNet();
	* // set the parameters
	* nnet.setParams({ learnRate: 1, momentum: 10, layout: [1, 4, 3] });
	*/
 exports.NNet.prototype.setParams &#x3D; function (params) { return Object.create(require(&#x27;qminer&#x27;).analytics.NNet.prototype); }
/**
	* Fits the model.
	* @param {(module:la.Vector|module:la.Matrix)} input1 - The input vector or matrix.
	* @param {(module:la.Vector|module:la.Matrix)} input2 - The input vector or matrix.
	* &amp;lt;br&gt; If input1 and input2 are both {@link module:la.Vector}, then the fitting is in online mode.
	* &amp;lt;br&gt; If input1 and input2 are both {@link module:la.Matrix}, then the fitting is in batch mode.
	* @returns {module:analytics.NNet} Self.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a Neural Networks model
	* var nnet &#x3D; new analytics.NNet({ layout: [2, 3, 4] });
	* // create the matrices for the fitting of the model
	* var matIn &#x3D; new la.Matrix([[1, 0], [0, 1]]);
	* var matOut &#x3D; new la.Matrix([[1, 1], [1, 2], [-1, 8], [-3, -3]]);
	* // fit the model
	* nnet.fit(matIn, matOut);
	*/
 exports.NNet.prototype.fit &#x3D; function (input1, input2) { return Object.create(require(&#x27;qminer&#x27;).analytics.NNet.prototype); }
/**
	* Sends the vector through the model and get the prediction.
	* @param {module:la.Vector} vec - The sent vector.
	* @returns {number} The prediction of the vector vec.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a Neural Networks model
	* var nnet &#x3D; new analytics.NNet({ layout: [2, 3, 4] });
	* // create the matrices for the fitting of the model
	* var matIn &#x3D; new la.Matrix([[1, 0], [0, 1]]);
	* var matOut &#x3D; new la.Matrix([[1, 1], [1, 2], [-1, 8], [-3, -3]]);
	* // fit the model
	* nnet.fit(matIn, matOut);
	* // create the vector for the prediction
	* var test &#x3D; new la.Vector([1, 1]);
	* // predict the value
	* var prediction &#x3D; nnet.predict(test);
	*/
 exports.NNet.prototype.predict &#x3D; function (vec) { return 0.0; }
/**
	* Saves the model.
	* @param {module:fs.FOut} fout - The output stream.
	* @returns {module:fs.FOut} The output stream fout.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	* // create a Neural Networks model
	* var nnet &#x3D; new analytics.NNet({ layout: [2, 3, 4] });
	* // create the matrices for the fitting of the model
	* var matIn &#x3D; new la.Matrix([[1, 0], [0, 1]]);
	* var matOut &#x3D; new la.Matrix([[1, 1], [1, 2], [-1, 8], [-3, -3]]);
	* // fit the model
	* nnet.fit(matIn, matOut);
	* // create an output stream object and save the model
	* var fout &#x3D; fs.openWrite(&#x27;nnet_example.bin&#x27;);
	* nnet.save(fout);
	* fout.close();
	* // load the Neural Network model from the binary
	* var fin &#x3D; fs.openRead(&#x27;nnet_example.bin&#x27;);
	* var nnet2 &#x3D; new analytics.NNet(fin);
	*/
 exports.NNet.prototype.save &#x3D; function (fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); } 
/**
* @typedef {Object} tokenizerParam
* @property {string} type - The type of the tokenizer. The different types are: 
*&amp;lt;br&gt;&quot;simple&quot; -
*&amp;lt;br&gt;&quot;html&quot; -
*&amp;lt;br&gt;&quot;unicode&quot; -
*/
/**
 * Tokenizer
 * @class 
 * @classdesc Breaks text into tokens (i.e. words).
 * @param {module:analytics.tokenizerParam} param - The constructor parameters.
 * @example
 * // import analytics module
 * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
 * // construct model
 * var tokenizer &#x3D; new analytics.Tokenizer({ type: &quot;simple&quot; })
 */
 exports.Tokenizer &#x3D; function (param) { return Object.create(require(&quot;qminer&quot;).analytics.Tokenizer.prototype); }
/**
	* This function tokenizes given strings and returns it as an array of strings.
	* @param {String} str - String of text you want to tokenize.
	* @returns {Array.&amp;lt;String&gt;} Returns array of strings. The number of strings in this array is equal to number of words in input string parameter.
	* Only keeps words, skips all punctuation.
	* Tokenizing contractions (i.e. don&#x27;t) depends on which type you use. Type &#x27;html&#x27; breaks contractions into 2 tokens.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // construct model
	* var tokenizer &#x3D; new analytics.Tokenizer({ type: &quot;simple&quot; });
	* // string you wish to tokenize
	* var string &#x3D; &quot;What a beautiful day!&quot;;
	* // tokenize string using getTokens
	* var tokens &#x3D; tokenizer.getTokens(string);
	* // output:
	* tokens &#x3D; [&quot;What&quot;, &quot;a&quot;, &quot;beautiful&quot;, &quot;day&quot;];
	*/
 exports.Tokenizer.prototype.getTokens &#x3D; function (str) { return [&quot;&quot;]; }
/**
	* This function breaks text into sentences and returns them as an array of strings.
	* @param {String} str - String of text you want to break into sentences.
	* @returns {Array.&amp;lt;String&gt;} Returns array of strings. The number of strings in this array is equal to number of sentences in input string parameter.
	* How function breaks sentences depends on where you use a full-stop, exclamation mark, question mark or the new line command.
	* Careful: the space between the lines is not ignored. 
	* With all 3 types this function returns sentences as they are.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // construct model
	* var tokenizer &#x3D; new analytics.Tokenizer({ type: &quot;simple&quot; });
	* // string you wish to tokenize
	* var string &#x3D; &quot;C++? Alright. Let&#x27;s do this!&quot;;
	* // tokenize text using getSentences
	* var tokens &#x3D; tokenizer.getSentences(string);
	* // output:
	* tokens &#x3D; [&quot;C++&quot;, &quot; Alright&quot;, &quot; Let&#x27;s do this&quot;];
	*/
 exports.Tokenizer.prototype.getSentences &#x3D; function (str) { return [&quot;&quot;]; }
/**
	* This function breaks text into paragraphs and returns them as an array of strings.
	* @param {String} str - String of text you want to break into paragraphs.
	* @returns {Array.&amp;lt;String&gt;} Returns array of strings. The number of strings in this array is equal to number of paragraphs in input string parameter.
	* When function detects commands &#x27;\n&#x27;, &#x27;\r&#x27; or &#x27;\t&#x27; it breaks text as new paragraph.
	* With all 3 types this function returns paragraphs as they are.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // construct model
	* var tokenizer &#x3D; new analytics.Tokenizer({ type: &quot;simple&quot; });
	* // string you wish to tokenize
	* var string &#x3D; &quot;Yes!\t No?\n Maybe...&quot;;
	* // tokenize text using getParagraphs
	* var tokens &#x3D; tokenizer.getParagraphs(string);
	* // output:
	* tokens &#x3D; [&quot;Yes&quot;, &quot; No&quot;, &quot; Maybe&quot;];
	*/
 exports.Tokenizer.prototype.getParagraphs &#x3D; function (str) { return [&quot;&quot;]; }
/**
* @typedef {Object} MDSParam
* @property {number} [maxSecs&#x3D;500] - The maximum time period to compute MDS of a matrix.
* @property {number} [maxStep&#x3D;5000] - The maximum number of iterations.
* @property {number} [minDiff&#x3D;1e-4] - The minimum difference criteria in MDS.
* @property {string} [distType&#x3D;&quot;Euclid&quot;] - The type of distance used. Available types: &quot;Euclid&quot;, &quot;Cos&quot;, &quot;SqrtCos&quot;.
*/
/**
* @class
* @classdesc Multidimensional scaling
* @param {(module:analytics~MDSParam | module:fs.FIn)} [params] - The parameters for the construction.
* @example
* // import analytics module
* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
* // construct a MDS instance
* var mds &#x3D; new analytics.MDS({ maxStep: 300, distType: &#x27;Cos&#x27; });
*/
 exports.MDS &#x3D; function (params) { return Object.create(require(&#x27;qminer&#x27;).analytics.MDS.prototype); }
/**
	* Get the parameters.
	* @returns {module:analytics~MDSParam} The json object containing the parameters of the instance.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a MDS instance
	* var mds &#x3D; new analytics.MDS();
	* // get the (default) parameters of the instance
	* // returns { maxStep: 5000, maxSecs: 300, minDiff: 1e-4, distType: &quot;Euclid&quot; }
	* var params &#x3D; mds.getParams();
	*/
 exports.MDS.prototype.getParams &#x3D; function () { return { maxStep: 0, maxSecs: 0, minDiff: 0, distType: &quot;&quot; }; }
/**
	* Set the parameters.
	* @param {module:analytics~MDSParam} params - The json object containing the parameters for the instance.
	* @example
	* // import analytics module
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* // create a MDS instance
	* var mds &#x3D; new analytics.MDS();
	* // get the (default) parameters of the instance
	* // returns { maxStep: 5000, maxSecs: 300, minDiff: 1e-4, distType: &quot;Euclid&quot; }
	* var params &#x3D; mds.getParams();
	*/
 exports.MDS.prototype.setParams &#x3D; function (params) { return { maxStep: 0, maxSecs: 0, minDiff: 0, distType: &quot;&quot; }; }
/**
	* Get the MDS of the given matrix.
	* @param {(module:la.Matrix | module:la.SparseMatrix)} mat - The multidimensional matrix.
	* @returns {module:la.Matrix} The matrix of dimensions mat.cols x 2, where the i-th row of the matrix is the 2d representation 
	* of the i-th column of mat.
	* @example
	* // import the modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a MDS instance
	* var mds &#x3D; new analytics.MDS();
	* // create the multidimensional matrix
	* var mat &#x3D; new la.Matrix({ rows: 50, cols: 10, random: true });
	* // get the 2d representation of mat 
	* var mat2d &#x3D; mds.fitTransform(mat); 
	*/
 exports.MDS.prototype.fitTransform &#x3D; function (mat) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
	* Save the MDS.
	* @param {module:fs.FOut} fout - The output stream.
	* @returns {module:fs.FOut} The output stram fout.
	* @example
	* // import modules
	* var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
	* var fs &#x3D; require(&#x27;qminer&#x27;).fs;
	* // create a MDS instance
	* var mds &#x3D; new analytics.MDS({ iter: 200, MaxStep: 10 });
	* // create the file output stream
	* var fout &#x3D; new fs.openWrite(&#x27;MDS.bin&#x27;);
	* // save the MDS instance
	* mds.save(fout);
	* fout.close();
	* // load the MDS instance
	* var fin &#x3D; fs.openRead(&#x27;MDS.bin&#x27;);
	* var mds2 &#x3D; new analytics.MDS(fin);
	*/
 exports.MDS.prototype.save &#x3D; function (fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }


    ///////////////////////////////////////////////////
    /////////////   DATA PREPROCESSING   //////////////
    ///////////////////////////////////////////////////

    /**
    * Preprocessing
    * @namespace
    * @desc Preprocessing functions for preparing labels in formats accepted
    * by learning moduls in qm.analytics.
    */
    var preprocessing &#x3D; preprocessing || {};
    // namespacing: http://addyosmani.com/blog/essential-js-namespacing/

    /**
    * Transforming arrays with labels to vector appropriate for binary classifiers.
    * @class
    * @classdesc
    * Transform given array of labels into binary vector with different
    * numeric value for elements when label matches specified label and
    * for other elements. By default, these values are +1 for matching
    * labels, and -1 for the rest.
    * @param {Array} y - labels
    * @param {(string | number)} positiveLabel - positive label
    * @param {number} [positiveId &#x3D; 1] - value when matching positive label
    * @param {number} [negativeId &#x3D; -1] - value when not matching positive label
    * @example
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // create binarizer with &#x27;b&#x27; as positive label
    * var binarizer &#x3D; new analytics.preprocessing.Binarizer(&#x27;b&#x27;);
    * // get vector with binarized labels
    * var bins &#x3D; binarizer.transform([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;]);
    */
    preprocessing.Binarizer &#x3D; function (positiveLabel, positiveId, negativeId) {
        if (positiveLabel &#x3D;&#x3D; undefined) { throw &quot;Binarizer needs positive label&quot;; }

        this.positiveLabel &#x3D; positiveLabel;
        this.positiveId &#x3D; (positiveId &#x3D;&#x3D; undefined) ? 1 : positiveId;
        this.negativeId &#x3D; (negativeId &#x3D;&#x3D; undefined) ? -1 : negativeId;

        this.fit &#x3D; function () {
            // do nothing
        }

        /**
        * Transform given array of labels to binary numeric vector.
        * @param {(Array&amp;lt;number&gt; | Array&amp;lt;string&gt; | module:la.Vector | module:la.StrVector)} y - labels
        * @return {modul:la.Vector} binarized vector
        */
        this.transform &#x3D; function (y) {
            var target &#x3D; new la.Vector();
            for (var i &#x3D; 0; i &amp;lt; y.length; i++) {
                target.push(y[i] &#x3D;&#x3D;&#x3D; this.positiveLabel ? this.positiveId : this.negativeId);
            }
            return target;
        }
    };

    preprocessing.applyModel &#x3D; function (model, X) {
        var target &#x3D; new la.Vector();
        for (var i &#x3D; 0; i &amp;lt; X.cols; i++) {
            target.push(model.decisionFunction(X[i]));
        }
        return target;
    }

    // Exports preprocessing namespace
    exports.preprocessing &#x3D; preprocessing;

    /**
    * SVM model.
    * @typedef {Object} svmModel
    * @property  {module:la.Vector} [svmModel.weigths] - SVM normal vector.
    */
    /**
	* Get the model.
	* @returns {module:analytics~svmModel} The current SVM model.
    * @example
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // create a SVC model
    * var SVC &#x3D; new analytics.SVC();
    * // get the properties of the model
    * var model &#x3D; SVC.getModel(); // returns { weight: new require(&#x27;qminer&#x27;).la.Vector(); }
	*/
    exports.SVC.prototype.getModel &#x3D; function() { return { weights: this.weights }; }
    /**
	* Get the model.
	* @returns {module:analytics~svmModel} Get current SVM model
    * @example
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // create a SVR model
    * var SVR &#x3D; new analytics.SVR();
    * // get the properties of the model
    * var model &#x3D; SVR.getModel(); // returns { weights: new require(&#x27;qminer&#x27;).la.Vector(); }
	*/
    exports.SVR.prototype.getModel &#x3D; function() { return { weights: this.weights }; }

    // Ridge Regression
    /**
    * @typedef {Object} ridgeRegModel
    * @property {module:la.Vector} [ridgeRegModel.weights] - The Ridge Regression model vector.
    */

    /**
    * Gets the model.
    * @returns {module:analytics~ridgeRegModel} Get current model.
    * @example
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // create the Ridge Regression model
    * var regmod &#x3D; new analytics.RidgeReg();
    * // get the model
    * var model &#x3D; regmod.getModel(); // returns { weights: new require(&#x27;qminer&#x27;).la.Vector(); }
    */
    exports.RidgeReg.prototype.getModel &#x3D; function () { return { weights: this.weights }; }

    // Recursive Linear Regression
    /**
    * @typedef {Object} recLinRegModel
    * @property {module:la.Vector} [recLinRegModel.weights] - Recursive Linear Regression model vector.
    */
    /**
    * Gets Recursive Linear Regression model
    * @returns {module:analytics~recLnRegModel} The current model.
    * @example
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // create the Recursive Linear Regression model
    * var linreg &#x3D; new analytics.RecLinReg({ dim: 10 });
    * // get the model
    * var model &#x3D; linreg.getModel(); // returns { weights: new require(&#x27;qminer&#x27;).la.Vector(); }
    */
    exports.RecLinReg.prototype.getModel &#x3D; function () { return { weights: this.weights } }

    /**
    * @typedef {Object} oneVsAllParam
    * The parameter given to the OneVsAll object. A Json object containing the parameter keys with values.
    * @param {function} [model] - Constructor for binary model to be
    * used internaly. Constructor should expect only one parameter.
    * @param {Object} [modelParam] - Parameter for oneVsAllParam.model constructor.
    * @param {number} [categories] - Number of categories.
    * @param {boolean} [verbose &#x3D; false] - If false, the console output is supressed.
    */

    /**
    * @classdesc One vs. all model for multiclass prediction. Builds binary model
    * for each category and predicts the one with the highest score. Binary model is
    * provided as part of the constructor.
    * @class
    * @param {module:analytics~oneVsAllParam} [oneVsAllParam] - Constructor parameters.
    * @example
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // create a new OneVsAll object with the model analytics.SVC
    * var onevsall &#x3D; new analytics.OneVsAll({ model: analytics.SVC, modelParam: { c: 10, maxTime: 12000 }, cats: 2 });
    */
    exports.OneVsAll &#x3D; function (oneVsAllParam) {
        // remember parameters
        var model &#x3D; oneVsAllParam.model;
        var modelParam &#x3D; oneVsAllParam.modelParam;
        var cats &#x3D; oneVsAllParam.cats;
        var verbose &#x3D; oneVsAllParam.verbose &#x3D;&#x3D; undefined ? false : oneVsAllParam.verbose;
        // trained models
        var models &#x3D; [ ];

        /**
        * Gets the parameters.
        * @returns {Object} Json object containing the parameters.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // create a new OneVsAll object with the model analytics.SVC
        * var onevsall &#x3D; new analytics.OneVsAll({ model: analytics.SVC, modelParam: { c: 10, maxTime: 12000 }, cats: 2 });
        * // get the parameters
        * // returns the JSon object
        * // { model: analytics.SVC, modelParam: { c: 10, maxTime: 12000 }, cats: 2, models: [] }
        * var params &#x3D; onevsall.getParams();
        */
        this.getParams &#x3D; function () {
            return { model: model, modelParam: modelParam, cats: cats, models: models }
        };

        /**
        * Sets the parameters.
        * @returns {module:analytics.OneVsAll} Self. The parameters are changed.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // create a new OneVsAll object with the model analytics.SVC
        * var onevsall &#x3D; new analytics.OneVsAll({ model: analytics.SVC, modelParam: { c: 10, maxTime: 12000 }, cats: 2 });
        * // set the parameters
        * var params &#x3D; onevsall.setParams({ model: analytics.SVR, modelParam: { c: 12, maxTime: 10000}, cats: 3, verbose: true });
        */
        this.setParams &#x3D; function (oneVsAllParam) {
            model &#x3D; oneVsAllParam.model &#x3D;&#x3D; undefined ? model : oneVsAllParam.model;
            modelParam &#x3D; oneVsAllParam.modelParam &#x3D;&#x3D; undefined ? modelParam : oneVsAllParam.modelParam;
            cats &#x3D; oneVsAllParam.cats &#x3D;&#x3D; undefined ? cats : oneVsAllParam.cats;
            verbose &#x3D; oneVsAllParam.verbose &#x3D;&#x3D; undefined ? verbose : oneVsAllParam.verbose;
        }

        /**
         * Apply all models to the given vector and returns a vector of scores, one for each category.
         * Semantic of scores depand on the provided binary model.
         * @param {module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix} X -
         * Input feature vector or matrix with feature vectors as columns.
         * @returns {module:la.Vector | module:la.Matrix} The score and label of the input:
         * &amp;lt;br&gt;1. {@link module:la.Vector} of scores, if X is of type {@link module:la.Vector} or {@link module:la.SparseVector}.
         * &amp;lt;br&gt;2. {@link module:la.Matrix} with columns corresponding to instances, and rows corresponding to labels, if X is of type {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
         * @example
         * // import modules
         * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
         * var la &#x3D; require(&#x27;qminer&#x27;).la;
         * // create a new OneVsAll object with the model analytics.SVC
         * var onevsall &#x3D; new analytics.OneVsAll({ model: analytics.SVC, modelParam: { c: 10, maxTime: 12000 }, cats: 2 });
         * // create the data (matrix and vector) used to fit the model
         * var matrix &#x3D; new la.Matrix([[1, 2, 1, 1], [2, 1, -3, -4]]);
         * var vector &#x3D; new la.Vector([0, 0, 1, 1]);
         * // fit the model
         * onevsall.fit(matrix, vector);
         * // create the vector for the decisionFunction
         * var test &#x3D; new la.Vector([1, 2]);
         * // give the vector to the decision function
         * var prediction &#x3D; onevsall.predict(test); // returns the vector of scores
         */
        this.decisionFunction &#x3D; function(X) {
            // check what is our input
            if (X instanceof la.Vector || X instanceof la.SparseVector) {
                // evaluate all models
                var scores &#x3D; new la.Vector();
                for (var cat &#x3D; 0; cat &amp;lt; cats; cat++) {
                    scores.push(models[cat].decisionFunction(X));
                }
                return scores;
            } else if (X instanceof la.Matrix || X instanceof la.SparseMatrix) {
                // create matrix where cols are instances and rows are scores for categories
                var scores &#x3D; new la.Matrix({rows: cats, cols: X.cols});
                for (var i &#x3D; 0; i &amp;lt; X.cols; i++) {
                    var x_i &#x3D; X.getCol(i);
                    for (var cat &#x3D; 0; cat &amp;lt; cats; cat++) {
                        scores.put(cat, i, models[cat].decisionFunction(x_i));
                    }
                }
                return scores;
            } else {
                throw &quot;analytics.OneVsAll.decisionFunction: Input data of unsupported type!&quot;;
            }
        }

        /**
         * Apply all models to the given vector and returns category with the highest score.
         * @param {module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix} X -
         * Input feature vector or matrix with feature vectors as columns.
         * @returns {number | module:la.IntVector} Returns:
         * &amp;lt;br&gt;1. number of the category with the higher score, if X is {@link module:la.Vector} or {@link module:la.SparseVector}.
         * &amp;lt;br&gt;2. {@link module:la.IntVector} of categories with the higher score for each column of X, if X is {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
         * @example
         * // import modules
         * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
         * var la &#x3D; require(&#x27;qminer&#x27;).la;
         * // create a new OneVsAll object with the model analytics.SVC
         * var onevsall &#x3D; new analytics.OneVsAll({ model: analytics.SVC, modelParam: { c: 10, maxTime: 12000 }, cats: 2 });
         * // create the data (matrix and vector) used to fit the model
         * var matrix &#x3D; new la.Matrix([[1, 2, 1, 1], [2, 1, -3, -4]]);
         * var vector &#x3D; new la.Vector([0, 0, 1, 1]);
         * // fit the model
         * onevsall.fit(matrix, vector);
         * // create the vector for the prediction
         * var test &#x3D; new la.Vector([1, 2]);
         * // get the prediction of the vector
         * var prediction &#x3D; onevsall.predict(test); // returns 0
         */
        this.predict &#x3D; function(X) {
            // evaluate all models
            var scores &#x3D; this.decisionFunction(X);
            // select maximal one
            if (scores instanceof la.Vector) {
                return scores.getMaxIdx();
            } else if (scores instanceof la.Matrix) {
                var predictions &#x3D; new la.IntVector();
                for (var i &#x3D; 0; i &amp;lt; scores.cols; i++) {
                    predictions.push(scores.getCol(i).getMaxIdx());
                }
                return predictions;
            } else {
                throw &quot;analytics.OneVsAll.predict: decisionFunction returns unsupported type!&quot;;
            }
        }

        // X &#x3D; feature matrix
        // y &#x3D; target label from 0..cats
        /**
         * Apply all models to the given vector and returns category with the highest score.
         * @param {module:la.Matrix | module:la.SparseMatrix} X - training instance feature vectors.
         * @param {module:la.Vector} y - target category for each training instance. Categories must
         * be integer numbers between 0 and oneVsAllParam.categories - 1.
         * @returns {module:analytics.OneVsAll} Self. The models are now fitted.
         * @example
         * // import modules
         * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
         * var la &#x3D; require(&#x27;qminer&#x27;).la;
         * // create a new OneVsAll object with the model analytics.SVC
         * var onevsall &#x3D; new analytics.OneVsAll({ model: analytics.SVC, modelParam: { c: 10, maxTime: 12000 }, cats: 2 });
         * // create the data (matrix and vector) used to fit the model
         * var matrix &#x3D; new la.Matrix([[1, 2, 1, 1], [2, 1, -3, -4]]);
         * var vector &#x3D; new la.Vector([0, 0, 1, 1]);
         * // fit the model
         * onevsall.fit(matrix, vector);
         */
        this.fit &#x3D; function(X, y) {
            models &#x3D; [ ];
            // make model for each category
            for (var cat &#x3D; 0; cat &amp;lt; cats; cat++) {
                if (verbose) {
                    console.log(&quot;Fitting label&quot;, (cat + 1), &quot;/&quot;, cats);
                };
                // prepare targert vector for current category
                var target &#x3D; (y instanceof la.Matrix) ?
                    // we have a special bianary vector for each category, make it into -1/+1
                    (new exports.preprocessing.Binarizer(1)).transform(y.getRow(cat)) :
                    // we have a vector with label for each element, get out -1/+1 vector
                    (new exports.preprocessing.Binarizer(cat)).transform(y);
                // get the model
                var catModel &#x3D; new model(modelParam);
                models.push(catModel.fit(X, target));
            }
            if (verbose) {
                console.log(&quot;Done!&quot;);
            };
            return this;
        }
    };

    exports.ThresholdModel &#x3D; function(params) {
        // what do we optimize
        this.target &#x3D; params.target;
        if (this.target &#x3D;&#x3D;&#x3D; &quot;recall&quot; || this.target &#x3D;&#x3D;&#x3D; &quot;precision&quot;) {
            this.level &#x3D; params.level;
        }
        // threshold model
        this.model &#x3D; null;

        // apply all models to the given vector and return distance to the class boundary
        // x &#x3D; dense vector with prediction score for each class
        // result &#x3D; traslated predictions based on thresholds
        this.decisionFunction &#x3D; function(x) {
            if (x instanceof Number) {
                // just transate based on the model&#x27;s threshold
                return x - this.model;
            } else if (x instanceof la.Vector) {
                // each element is a new instance
                var scores &#x3D; new la.Vector();
                for (var i &#x3D; 0; i &amp;lt; x.length; i++) {
                    scores.push(x[i] - this.model);
                }
                return scores;
            } else {
                throw &quot;analytics.ThresholdModel.decisionFunction: Input data of unsupported type!&quot;;
            }
        }

        // return the most likely category
        // x &#x3D; dense vector with prediction score for each class
        // result &#x3D; array of positive label ids
        this.predict &#x3D; function(x) {
            // evaluate all models
            var scores &#x3D; this.decisionFunction(x)
            // check what we get
            if (scores instanceof la.Vector) {
                return res &#x3D; new la.Vector();
                for (var i &#x3D; 0; i &amp;lt; scores.length; i++) {
                    res.push(scores[i] &gt; 0 ? 1 : -1);
                }
                return res;
            } else {
                return scores &gt; 0 ? 1 : -1;
            }
        }

        // X &#x3D; vector of predictions for each instance (output of decision_funcition)
        // y &#x3D; target labels (1 or -1)
        this.fit &#x3D; function(X, y) {
            if (this.target &#x3D;&#x3D;&#x3D; &quot;f1&quot;) {
                // find threshold that maximizes F1 measure
                this.model &#x3D; exports.metrics.bestF1Threshold(y, X);
            } else if (this.target &#x3D;&#x3D;&#x3D; &quot;recall&quot;) {
                // find threshold that results in desired recall
                this.model &#x3D; exports.metrics.desiredRecallThreshold(y, X, this.level);
            } else if (this.target &#x3D;&#x3D;&#x3D; &quot;precision&quot;) {
                // find threshold that results in desired precision
                this.model &#x3D; exports.metrics.desiredPrecisionThreshold(y, X, this.level);
            } else {
                throw &quot;Unknown threshold model target: &quot; + this.target;
            }
        }
    }


    /**
    * Metrics
    * @namespace
    * @desc Classification and regression metrics
    * @example &amp;lt;caption&gt;Batch classification example&amp;lt;/caption&gt;
    * // import metrics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    *
    * // true and predicted lables
    * var true_lables &#x3D; [0, 1, 0, 0, 1];
    * var pred_prob &#x3D; [0.3, 0.5, 0.2, 0.5, 0.8];
    *
    * // compute ROC curve
    * var roc &#x3D; analytics.metrics.rocCurve(true_lables, pred_prob);
    * @example &amp;lt;caption&gt;Online classification example&amp;lt;/caption&gt;
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // true and predicted lables
    * var true_lables &#x3D; [0, 1, 0, 0, 1];
    * var pred_prob &#x3D; [0.3, 0.5, 0.2, 0.5, 0.8];
    *
    * // create predictionCurve instance
    * var predictionCurve &#x3D; new analytics.metrics.PredictionCurve();
    *
    * // simulate data flow
    * for (var i in true_lables) {
    *    // push new value
    *    predictionCurve.push(true_lables[i], pred_prob[i]);
    *}
    *
    * var roc &#x3D; predictionCurve.roc(); // get ROC
    * @example &amp;lt;caption&gt;Batch regression example&amp;lt;/caption&gt;
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // true and predicted data
    * var true_vals &#x3D; [1, 2, 3, 4, 5];
    * var pred_vals &#x3D; [3, 4, 5, 6, 7];
    *
    * // use batch MAE method
    * analytics.metrics.meanAbsoluteError(true_vals, pred_vals);
    * @example &amp;lt;caption&gt;Online regression example&amp;lt;/caption&gt;
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // true and predicted data
    * var true_vals &#x3D; [1, 2, 3, 4, 5];
    * var pred_vals &#x3D; [3, 4, 5, 6, 7];
    *
    * // create online MAE metric instance
    * var mae &#x3D; new analytics.metrics.MeanAbsoluteError();
    *
    * // simulate data flow
    * for (var i in true_vals) {
    *   // push new value
    *   mae.push(true_vals[i], pred_vals[i]);
    * }
    * // get updated error
    * mae.getError();
    */
    var metrics &#x3D; metrics || {};
    // namespacing: http://addyosmani.com/blog/essential-js-namespacing/

    ///////////////////////////////////////////////////
    ///////////// CLASSIFICATION METRICS //////////////
    ///////////////////////////////////////////////////

    /**
    * For evaluating provided categories from binary? classifiers.
    * @class
    * @classdesc Class implements several classification measures (precision, recall, F1, accuracy)
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lable(s)
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Predicted (estimated) lable(s)
    */
    metrics.ClassificationScore &#x3D; function (yTrue, yPred) {
        /**
        * Returns &#x60;Object&#x60; containing different classification measures
        * @returns {Object} scores - Object with different classification socres
        * @returns {number} scores.count - Count
        * @returns {number} scores.TP - Number of true positives
        * @returns {number} scores.TN - Number of true negative
        * @returns {number} scores.FP - Number of false positives
        * @returns {number} scores.FN - Number of false positives
        * @returns {number} scores.all - Number of all results
        * @returns {number} scores.accuracy - Accuracy score. Formula: (tp + tn) / (tp + fp + fn + tn)
        * @returns {number} scores.precision - Precision score. Formula: tp / (tp + fp)
        * @returns {number} scores.recall - Recall score. Formula: tp / (tp + fn)
        * @returns {number} scores.f1 - F1 score. Formula:  2 * (precision * recall) / (precision + recall)
        */
        this.scores &#x3D; {
            count: 0, predictionCount: 0,
            TP: 0, TN: 0, FP: 0, FN: 0,
            all: function () { return this.TP + this.FP + this.TN + this.FN; },
            precision: function () { return (this.FP &#x3D;&#x3D; 0) ? 1 : this.TP / (this.TP + this.FP); },
            recall: function () { return (this.FN &#x3D;&#x3D; 0) ? 1 : this.TP / (this.TP + this.FN); },
            f1: function () { return ((this.precision() + this.recall()) &#x3D;&#x3D; 0) ? 0 :
                2 * this.precision() * this.recall() / (this.precision() + this.recall()); },
            accuracy: function () { return (this.TP + this.TN) / this.all(); }
        };

        /**
        * Adds prediction to the current statistics. Labels can be either integers
        * or integer array (when there are zero or more then one lables).
        * @param {number} correct - Correct lable.
        * @param {number} predicted - Predicted lable.
        */
        this.push &#x3D; function (correct, predicted) {
            var catCorrect &#x3D; (correct &gt; 0);
            var catPredicted &#x3D; (predicted &gt; 0);
            // update counts for correct categories
            if (catCorrect) { this.scores.count++; }
            // update counts for how many times category was predicted
            if (catPredicted) { this.scores.predictionCount++; }
            // update true/false positive/negative count
            if (catCorrect &amp;amp;&amp;amp; catPredicted) {
                // both predicted and correct say true
                this.scores.TP++;
            } else if (catCorrect) {
                // this was only correct but not predicted
                this.scores.FN++;
            } else if (catPredicted) {
                // this was only predicted but not correct
                this.scores.FP++;
            } else {
                // both predicted and correct say false
                this.scores.TN++;
            }
        };

        // initialize if we are passed the data
        if (arguments.length &gt;&#x3D; 2) {
            for (var i &#x3D; 0; i &amp;lt; yTrue.length; i++) {
                this.push(yTrue[i], yPred[i]);
            }
        }

        // check if input parameters are of correct type and binary
        for (var i &#x3D; 0; i &amp;lt; arguments.length; i++) {
            // check type
            var argumentType &#x3D; arguments[i].constructor.name;
            if (argumentType !&#x3D;&#x3D; &quot;Array&quot; &amp;amp;&amp;amp; argumentType !&#x3D;&#x3D; &quot;Vector&quot;) {
                throw new TypeError(&#x27;input param must be of type &quot;Array&quot; or &quot;Vector&quot;, but is &#x27; + argumentType + &#x27; instead&#x27;);
            }
        }
    };

    /**
    * Accuracy score is the proportion of true results (both true positives and true negatives)
    * among the total number of cases examined.
    * Formula: (tp + tn) / (tp + fp + fn + tn).
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Predicted (estimated) lables
    * @returns {number} Accuracy value
    */
    metrics.accuracyScore &#x3D; function (yTrue, yPred) {
        return new metrics.ClassificationScore(yTrue, yPred).scores.accuracy();
    };

    /**
    * Precision score is defined as the proportion of the true positives against all the
    * positive results (both true positives and false positives).
    * Formula: tp / (tp + fp).
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Predicted (estimated) lables
    * @returns {number} Precission score
    */
    metrics.precisionScore &#x3D; function (yTrue, yPred) {
        return new metrics.ClassificationScore(yTrue, yPred).scores.precision();
    };

    /**
    * Recall score is intuitively the ability of the classifier to find all the positive samples.
    * Formula: tp / (tp + fn).
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Predicted (estimated) lables
    * @returns {number} Recall score
    */
    metrics.recallScore &#x3D; function (yTrue, yPred) {
        return new metrics.ClassificationScore(yTrue, yPred).scores.recall();
    };

    /**
    * The F1 score can be interpreted as a weighted average of the precision and recall, where
    * an F1 score reaches its best value at 1 and worst score at 0. The relative contribution of
    * precision and recall to the F1 score are equal.
    * Formula: 2 * (precision * recall) / (precision + recall)
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Predicted (estimated) lables
    * @returns {number} F1 score
    */
    metrics.f1Score &#x3D; function (yTrue, yPred) {
        return new metrics.ClassificationScore(yTrue, yPred).scores.f1();
    };

    /**
    * Class implements several prediction curve measures (ROC, AOC, Precision-Recall, ...)
    * @class
    * @classdesc used for computing ROC curve and other related measures such as AUC
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lable(s) of binary classification in range {-1, 1} or {0, 1}.
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @example
    * // import metrics module
    * var metrics &#x3D; require(&#x27;qminer&#x27;).analytics.metrics;
    *
    * // true and predicted lables
    * var true_lables &#x3D; [0, 1, 0, 0, 1];
    * var pred_prob &#x3D; [0.3, 0.5, 0.2, 0.5, 0.8];
    *
    * // create predictionCurve instance
    * var predictionCurve &#x3D; new metrics.PredictionCurve();
    *
    * // simulate data flow
    * for (var i in true_lables) {
    *    // push new value
    *    predictionCurve.push(true_lables[i], pred_prob[i]);
    *}
    *
    * var roc &#x3D; predictionCurve.roc(); // get ROC
    * var auc &#x3D; predictionCurve.auc(); // get AUC
    * var pr &#x3D; predictionCurve.precisionRecallCurve() // get precision-recall curve
    */
    metrics.PredictionCurve &#x3D; function (yTrue, yPred) {
        /**
        * Count of all examples
        * @name module:analytics~metrics.PredictionCurve#length
        * @type number
        */
        this.length &#x3D; 0;
        /**
        * Count of all positive examples
        * @name module:analytics~metrics.PredictionCurve#allPositives
        * @type number
        */
        this.allPositives &#x3D; 0;
        /**
        * Count of all negative examples
        * @name module:analytics~metrics.PredictionCurve#allNegatives
        * @type number
        */
        this.allNegatives &#x3D; 0;
        // store of predictions and ground truths
        /**
        * Store of ground truths
        * @name module:analytics~metrics.PredictionCurve#grounds
        * @type module:la.Vector
        */
        this.grounds &#x3D; new la.Vector();
        /**
        * Store of predictions
        * @name module:analytics~metrics.PredictionCurve#predictions
        * @type module:la.Vector
        */
        this.predictions &#x3D; new la.Vector();

        /**
        * Add new measurement with ground score (1 or -1) and predicted value
        * or integer array (when there are zero or more then one lables).
        * @param {number} ground - Correct lable.
        * @param {number} predicted - Estimated probabilities.
        */
        this.push &#x3D; function (ground, predict) {
            // remember the scores
            this.grounds.push(ground)
            this.predictions.push(predict);
            // update counts
            this.length++;
            if (ground &gt; 0) {
                this.allPositives++;
            } else {
                this.allNegatives++;
            }
        };

        // initialize if we are given data
        if (arguments.length &gt;&#x3D; 2) {
            for (var i &#x3D; 0; i &amp;lt; yTrue.length; i++) {
                this.push(yTrue[i], yPred[i]);
            }
        }

        // check if input parameters are of correct type and binary
        for (var i &#x3D; 0; i &amp;lt; arguments.length; i++) {
            // check type
            var argumentType &#x3D; arguments[i].constructor.name;
            if (argumentType !&#x3D;&#x3D; &quot;Array&quot; &amp;amp;&amp;amp; argumentType !&#x3D;&#x3D; &quot;Vector&quot;) {
                throw new TypeError(&#x27;input param must be of type &quot;Array&quot; or &quot;Vector&quot;, but is &#x27; + argumentType + &#x27; instead&#x27;);
            }
        }

        /**
        * Get  Receiver Operating Characteristic (ROC) parametrization sampled on &#x60;sample&#x60; points
        * @param {number} [sample&#x3D;10] - Desired number of samples in output
        * @returns {module:la.Matrix} A matrix with increasing false and true positive rates
        */
        this.roc &#x3D; function (sample) {
            // default sample size is 10
            sample &#x3D; sample || 10;
            // sort according to predictions
            var perm &#x3D; this.predictions.sortPerm(false);
            // maintaining the results as we go along
            var TP &#x3D; 0, FP &#x3D; 0, ROC &#x3D; [[0, 0]];

            // check input samples
            if (this.allNegatives &#x3D;&#x3D; 0) throw new Error(&#x27;No positive samples in yTrue, true positive value should be meaningless.&#x27;);
            if (this.allNegatives &#x3D;&#x3D; this.length) throw new Error(&#x27;No negative samples in yTrue, false positive value should be meaningless.&#x27;);

            // for figuring out when to dump a new ROC sample
            var unique &#x3D; 1;
            for (var i &#x3D; 1; i &amp;lt; perm.perm.length; i++) {
                if (Math.abs(perm.vec[i] - perm.vec[i - 1]) &gt; 1e-8) {
                    unique++;
                }
            }

            var next &#x3D; Math.floor(unique / sample);

            // go over the sorted results
            for (var i &#x3D; 0; i &amp;lt; perm.perm.length; i++) {
                // get the ground
                var ground &#x3D; this.grounds[perm.perm[i]];
                // update TP/FP counts according to the ground
                if (ground &gt; 0) { TP++ } else { FP++; }

                // see if time to do next save
                if ((i &amp;lt; perm.perm.length - 1) &amp;amp;&amp;amp; (Math.abs(perm.vec[i] - perm.vec[i + 1]) &gt; 1e-8)) {
                    next &#x3D; next - 1;
                }

                if (next &amp;lt; 0) {
                    // add new datapoint to the curve
                    ROC.push([FP / this.allNegatives, TP / this.allPositives]);
                    // setup next timer
                    next &#x3D; Math.floor(unique / sample);
                }
            }
            // add the last point
            ROC.push([1, 1]);
            // return ROC
            return ROC;
        }

        /**
        * Get Area Under the Curve (AUC) of the current curve
        * @param {number} [sample&#x3D;10] - Desired number of samples in output
        * @returns {number} Area under ROC curve
        */
        this.auc &#x3D; function (sample) {
            // default sample size is 10
            sample &#x3D; sample || 10;
            // get the curve
            var curve &#x3D; this.roc(sample);
            // compute the area
            var result &#x3D; 0;
            for (var i &#x3D; 1; i &amp;lt; curve.length; i++) {
                // get edge points
                var left &#x3D; curve[i - 1];
                var right &#x3D; curve[i];
                // first the rectangle bellow
                result &#x3D; result + (right[0] - left[0]) * left[1];
                // an then the triangle above
                result &#x3D; result + (right[0] - left[0]) * (right[1] - left[1]) / 2;
            }
            return result;
        }

        /**
        * evalPrecisionRecall
        * @private
        * @param {callback} callback
        */
        this.evalPrecisionRecall &#x3D; function (callback) {
            // sort according to predictions
            var perm &#x3D; this.predictions.sortPerm(false);
            // maintaining the results as we go along
            var TP &#x3D; 0, FP &#x3D; 0, TN &#x3D; this.allNegatives, FN &#x3D; this.allPositives;
            // go over the sorted results
            for (var i &#x3D; 0; i &amp;lt; perm.perm.length; i++) {
                // get the ground
                var ground &#x3D; this.grounds[perm.perm[i]];
                // update TP/FP counts according to the ground
                if (ground &gt; 0) { TP++; FN--; } else { FP++; TN--; }
                // do the update
                if ((TP + FP) &gt; 0 &amp;amp;&amp;amp; (TP + FN) &gt; 0 &amp;amp;&amp;amp; TP &gt; 0) {
                    // compute current precision and recall
                    var precision &#x3D; TP / (TP + FP);
                    var recall &#x3D; TP / (TP + FN);
                    // see if we need to update current bep
                    callback.update(ground, perm.vec[i], precision, recall);
                }
            }
            return callback.finish();
        }

        /**
        * Get precision recall curve sampled on &#x60;sample&#x60; points
        * @param {number} [sample&#x3D;10] - Desired number of samples in output
        * @returns {module:la.Matrix} Precision-recall pairs.
        */
        this.precisionRecallCurve &#x3D; function (sample) {
            return this.evalPrecisionRecall(new function (sample, length) {
                // default sample size is 10
                this.sample &#x3D; sample || 10;
                // curve
                this.curve &#x3D; [[0, 1]];
                // for figuring out when to dump a new ROC sample
                this.next &#x3D; Math.floor(length / (this.sample));
                this.counter &#x3D; this.next;
                // keep last value
                this.precision &#x3D; 0; this.recall &#x3D; 0;
                // handlers
                this.update &#x3D; function (yTrue, yPred, precision, recall) {
                    this.counter &#x3D; this.counter - 1;
                    if (this.counter &amp;lt;&#x3D; 0) {
                        // add to the curve
                        this.curve.push([recall, precision]);
                        // setup next timer
                        this.counter &#x3D; this.next;
                    }
                    // always remember last value
                    this.precision &#x3D; precision; this.recall &#x3D; recall;
                }
                this.finish &#x3D; function () {
                    // add the last point
                    this.curve.push([this.recall, this.precision]);
                    return this.curve;
                }
            }(sample, this.length));
        };

        /**
        * Get break-even point, the value where precision and recall intersect
        * @returns {number} Break-even point.
        */
        this.breakEvenPoint &#x3D; function () {
            return this.evalPrecisionRecall(new function () {
                this.minDiff &#x3D; 1.0; this.bep &#x3D; -1.0;
                this.update &#x3D; function (yTrue, yPred, precision, recall) {
                    var diff &#x3D; Math.abs(precision - recall);
                    if (diff &amp;lt; this.minDiff) { this.minDiff &#x3D; diff; bep &#x3D; (precision + recall) / 2; }
                }
                this.finish &#x3D; function () { return this.bep; }
            }());
        }

        /**
        * Gets threshold for prediction score, which results in the highest F1
        * @returns {number} Threshold with highest F1 score.
        */
        this.bestF1 &#x3D; function () {
            return this.evalPrecisionRecall(new function () {
                this.maxF1 &#x3D; 0.0; this.threshold &#x3D; 0.0;
                this.update &#x3D; function (yTrue, yPred, precision, recall) {
                    var f1 &#x3D; 2 * precision * recall / (precision + recall);
                    if (f1 &gt; this.maxF1) {
                        this.maxF1 &#x3D; f1;
                        this.threshold &#x3D; yPred;
                    }
                }
                this.finish &#x3D; function () { return this.threshold; }
            }());
        }

        /**
        * Gets threshold for prediction score, nearest to specified recall
        * @param {number} desiredRecall - Desired recall score.
        * @returns {number} recal score threshold - Threshold for recall score, nearest to specified &#x60;recall&#x60;
        */
        this.desiredRecall &#x3D; function (desiredRecall) {
            return this.evalPrecisionRecall(new function () {
                this.recallDiff &#x3D; 1.0; this.threshold &#x3D; 0.0;
                this.update &#x3D; function (yTrue, yPred, precision, recall) {
                    var diff &#x3D; Math.abs(desiredRecall - recall);
                    if (diff &amp;lt; this.recallDiff) {
                        this.recallDiff &#x3D; diff;
                        this.threshold &#x3D; yPred;
                    }
                }
                this.finish &#x3D; function () { return this.threshold; }
            }());
        }

        /**
        * Gets threshold for prediction score, nearest to specified precision
        * @param {number} desiredPrecision - Desired precision score.
        * @returns {number} Threshold for prediction score, nearest to specified &#x60;precision&#x60;
        */
        this.desiredPrecision &#x3D; function (desiredPrecision) {
            return this.evalPrecisionRecall(new function () {
                this.precisionDiff &#x3D; 1.0; this.threshold &#x3D; 0.0;
                this.update &#x3D; function (yTrue, yPred, precision, recall) {
                    var diff &#x3D; Math.abs(desiredPrecision - precision);
                    if (diff &amp;lt; this.precisionDiff) {
                        this.precisionDiff &#x3D; diff;
                        this.threshold &#x3D; yPred;
                    }
                }
                this.finish &#x3D; function () { return this.threshold; }
            }());
        }
    };

    /**
    * Get ROC parametrization sampled on &#x60;sample&#x60; points
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @param {number} [sample&#x3D;10] - Desired number of samples in output
    * @returns {module:la.Matrix} A matrix with increasing false and true positive rates
    * @example
    * // import metrics module
    * var metrics &#x3D; require(&#x27;qminer&#x27;).analytics.metrics;
    *
    * // true and predicted lables
    * var true_lables &#x3D; [0, 1, 0, 0, 1];
    * var pred_prob &#x3D; [0.3, 0.5, 0.2, 0.5, 0.8];
    *
    * // compute ROC curve
    * var roc &#x3D; metrics.rocCurve(true_lables, pred_prob); // output: [ [ 0, 0 ], [0, 0.5], [[ 0.34, 1 ],], [ 0.67, 0 ], [ 1, 1 ] ]
    */
    metrics.rocCurve &#x3D; function (yTrue, yPred, sample) {
        return new metrics.PredictionCurve(yTrue, yPred).roc(sample);
    };

    /**
    * Get AUC of the current curve
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @param {number} [sample&#x3D;10] - Desired number of samples in output
    * @returns {number} Area under ROC curve
    * @example
    * // import metrics module
    * var metrics &#x3D; require(&#x27;qminer&#x27;).analytics.metrics;
    *
    * // true and predicted lables
    * var true_lables &#x3D; [0, 1, 0, 0, 1];
    * var pred_prob &#x3D; [0.3, 0.5, 0.2, 0.5, 0.8];
    *
    * // compute ROC curve
    * var auc &#x3D; metrics.rocAucScore(true_lables, pred_prob); // output: 0.92
    */
    metrics.rocAucScore &#x3D; function (yTrue, yPred, sample) {
        return new metrics.PredictionCurve(yTrue, yPred).auc(sample);
    };

    /**
    * Get precision recall curve sampled on &#x60;sample&#x60; points
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @param {number} [sample&#x3D;10] - Desired number of samples in output
    * @returns {module:la.Matrix} Precision-recall pairs
    */
    metrics.precisionRecallCurve &#x3D; function (yTrue, yPred, sample) {
        return new metrics.PredictionCurve(yTrue, yPred).precisionRecallCurve(sample);
    };

    /**
    * Get break-even point, the value where precision and recall intersect
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @returns {number} Break-even point score
    */
    metrics.breakEventPointScore &#x3D; function (yTrue, yPred) {
        return new metrics.PredictionCurve(yTrue, yPred).breakEvenPoint();
    };

    /**
    * Gets threshold for prediction score, which results in the highest F1
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @returns {number} Threshold with highest F1 score
    */
    metrics.bestF1Threshold &#x3D; function (yTrue, yPred) {
        return new metrics.PredictionCurve(yTrue, yPred).bestF1();
    };

    /**
    * Gets threshold for recall score, nearest to specified recall
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @param {number} desiredRecall - Desired recall score.
    * @returns {number} Threshold for recall score, nearest to specified &#x60;recall&#x60;
    */
    metrics.desiredRecallThreshold &#x3D; function (yTrue, yPred, desiredRecall) {
        return new metrics.PredictionCurve(yTrue, yPred).desiredRecall(desiredRecall);
    };

    /**
    * Gets threshold for prediction score, nearest to specified precision
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrue - Ground truth (correct) lables
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPred - Estimated probabilities
    * @param {number} desiredPrecision - Desired precision score.
    * @returns {number} Threshold for prediction score, nearest to specified &#x60;precision&#x60;
    */
    metrics.desiredPrecisionThreshold &#x3D; function (yTrue, yPred, desiredPrecision) {
        return new metrics.PredictionCurve(yTrue, yPred).desiredPrecision(desiredPrecision);
    };

    ///////////////////////////////////////////////////
    //////////// ONLINE REGRESSION METRICS ////////////
    ///////////////////////////////////////////////////

    // Online regression metrics used for evaluating online models

    // Main object for online metrics model
    /**
    * createOnlineMetric
    * @private
    * @class
    *
    * This provides methods used for event handling. It&#x27;s not meant to
    * be used directly.
    *
    */
    function createOnlineMetric(callback) {
        var error &#x3D; -1;
        this.metric &#x3D; new callback(); // We can hide this later (just delete this)

        // check if input types are of correct type
        function checkPushParams() {
            for (var i &#x3D; 0, j &#x3D; arguments.length; i &amp;lt; j; i++) {
                var argumentType &#x3D; arguments[i].constructor.name;
                if (argumentType !&#x3D;&#x3D; &quot;Number&quot;) {
                    throw new TypeError(&#x27;input param &#x27; + i + &#x27; must be of type &quot;Number&quot;, but is &#x27; + argumentType + &#x27; instead&#x27;);
                }
            }
        }

        /**
        * Updates metric with ground truth target value &#x60;yTrue&#x60; and estimated target value &#x60;yPred&#x60;.
        * @param {number} yTrue - Ground truth (correct) target value
        * @param {number} yPred - Estimated target value
        */
        this.push &#x3D; function (yTrue, yPred, ref_num) {
            // set default values of optional input parameters
            var yPred &#x3D; yPred &#x3D;&#x3D; null ? 0 : yPred;
            var ref_num &#x3D; ref_num &#x3D;&#x3D; null ? 0 : ref_num;
            // check if input types are of correct type
            checkPushParams(yTrue, yPred, ref_num);
            // calculate the error with provided function from the callback function
            error &#x3D; this.metric.update(yTrue, yPred);
        }

        /**
        * Returns error value.
        * @returns {number} Error value
        */
        this.getError &#x3D; function () {
            return error;
        }

        /**
	    * Save metric state to provided output stream &#x60;FOut&#x60;.
	    * @param {module:fs.FOut} FOut - The output stream.
	    * @returns {module:fs.FOut} Provided output stream &#x60;FOut&#x60;.
        */
        this.save &#x3D; function (fout) {
            fout.writeJson(this.metric.state);
            return fout;
        }

        /**
	    * Load metric state from provided input stream &#x60;FIn&#x60;.
	    * @param {module:fs.FIn} FIn - The output stream.
	    * @returns {module:fs.FIn} Provided output stream &#x60;FIn&#x60;.
        */
        this.load &#x3D; function (fin) {
            this.metric.state &#x3D; fin.readJson();
            error &#x3D; this.metric.state.error;
            return fin;
        }

    }

    // MEAN ERROR (ME)
    /**
    * Create new (online) mean error instance.
    * @class
    * @classdesc Online Mean Error (ME) instance
    * @param {module:fs.FIn} [FIn] - Saved state can be loaded via constructor
    * @extends module:analytics~createOnlineMetric
    */
    metrics.MeanError &#x3D; function (fin) {
        function metric() {
            this.name &#x3D; &quot;Mean Error&quot;
            this.shortName &#x3D; &quot;ME&quot;
            this.state &#x3D; {
                sumErr: 0,
                count: 0,
                error: 0
            }
            // update function
            this.update &#x3D; function (yTrue, yPred) {
                var err &#x3D; yTrue - yPred;
                this.state.sumErr +&#x3D; err;
                this.state.count++;
                this.state.error &#x3D; this.state.sumErr / this.state.count;
                return this.state.error;
            }
        }
        // create new metric instance, and load state from fin in defined
        var errorMetric &#x3D; new createOnlineMetric(metric);
        if (typeof fin !&#x3D;&#x3D; &#x27;undefined&#x27;) errorMetric.load(fin);

        return errorMetric;
    };

    // MEAN ABSOLUTE ERROR (MAE)
    /**
    * Create new (online) mean absolute error instance.
    * @class
    * @classdesc Online Mean Absolute Error (MAE) instance
    * @param {module:fs.FIn} [FIn] - Saved state can be loaded via constructor
    * @extends module:analytics~createOnlineMetric
    */
    metrics.MeanAbsoluteError &#x3D; function (fin) {
        function metric() {
            this.name &#x3D; &quot;Mean Absolute Error&quot;
            this.shortName &#x3D; &quot;MAE&quot;
            this.state &#x3D; {
                sumErr: 0,
                count: 0,
                error: 0
            }
            // update function
            this.update &#x3D; function (yTrue, yPred) {
                var err &#x3D; yTrue - yPred;
                this.state.sumErr +&#x3D; Math.abs(err);
                this.state.count++;
                this.state.error &#x3D; this.state.sumErr / this.state.count;
                return this.state.error;
            }
        }
        // create new metric instance, and load state from fin in defined
        var errorMetric &#x3D; new createOnlineMetric(metric);
        if (typeof fin !&#x3D;&#x3D; &#x27;undefined&#x27;) errorMetric.load(fin);

        return errorMetric;
    }

    // MEAN SQUARE ERROR (MSE)
    /**
    * Create new (online) mean square error instance.
    * @class
    * @classdesc Online Mean Square Error (MSE) instance
    * @param {module:fs.FIn} [FIn] - Saved state can be loaded via constructor
    * @extends module:analytics~createOnlineMetric
    */
    metrics.MeanSquareError &#x3D; function (fin) {
        function metric() {
            this.name &#x3D; &quot;Mean Square Error&quot;
            this.shortName &#x3D; &quot;MSE&quot;
            this.state &#x3D; {
                sumErr: 0,
                count: 0,
                error: 0
            }
            // update function
            this.update &#x3D; function (yTrue, yPred) {
                var err &#x3D; yTrue - yPred;
                this.state.sumErr +&#x3D; (err * err);
                this.state.count++;
                this.state.error &#x3D; this.state.sumErr / this.state.count;
                return this.state.error;
            }
        }
        // create new metric instance, and load state from fin in defined
        var errorMetric &#x3D; new createOnlineMetric(metric);
        if (typeof fin !&#x3D;&#x3D; &#x27;undefined&#x27;) errorMetric.load(fin);

        return errorMetric;
    }

    // ROOT MEAN SQUARE ERROR (RMSE)
    /**
    * Create new (online) root mean square error instance.
    * @class
    * @classdesc Online Root Mean Square Error (RMSE) instance
    * @param {module:fs.FIn} [FIn] - Saved state can be loaded via constructor
    * @extends module:analytics~createOnlineMetric
    */
    metrics.RootMeanSquareError &#x3D; function (fin) {
        function metric() {
            this.name &#x3D; &quot;Root Mean Square Error&quot;
            this.shortName &#x3D; &quot;RMSE&quot;
            this.state &#x3D; {
                sumErr: 0,
                count: 0,
                error: 0
            }
            // update function
            this.update &#x3D; function (yTrue, yPred) {
                var err &#x3D; yTrue - yPred;
                this.state.sumErr +&#x3D; (err * err);
                this.state.count++;
                this.state.error &#x3D; Math.sqrt(this.state.sumErr / this.state.count);
                return this.state.error;
            }
        }
        // create new metric instance, and load state from fin in defined
        var errorMetric &#x3D; new createOnlineMetric(metric);
        if (typeof fin !&#x3D;&#x3D; &#x27;undefined&#x27;) errorMetric.load(fin);

        return errorMetric;
    }

    // MEAN ABSOLUTE PERCENTAGE ERROR (MAPE)
    /**
    * Create new (online) mean absolute percentage error instance.
    * @class
    * @classdesc Online Mean Absolute Percentage Error (MAPE) instance
    * @param {module:fs.FIn} [FIn] - Saved state can be loaded via constructor
    * @extends module:analytics~createOnlineMetric
    */
    metrics.MeanAbsolutePercentageError &#x3D; function (fin) {
        function metric() {
            this.name &#x3D; &quot;Mean Absolute Percentage Error&quot;
            this.shortName &#x3D; &quot;MAPE&quot;
            this.state &#x3D; {
                sumErr: 0,
                count: 0,
                error: 0
            }
            // update function
            this.update &#x3D; function (yTrue, yPred) {
                if (yTrue !&#x3D; 0) { // skip if yTrue is 0, otherwise we have devision by zero in the next step.
                    var err &#x3D; yTrue - yPred;
                    this.state.sumErr +&#x3D; Math.abs(err / yTrue) * 100;
                }
                this.state.count++;
                this.state.error &#x3D; this.state.sumErr / this.state.count;
                return this.state.error;
            }
        }
        // create new metric instance, and load state from fin in defined
        var errorMetric &#x3D; new createOnlineMetric(metric);
        if (typeof fin !&#x3D;&#x3D; &#x27;undefined&#x27;) errorMetric.load(fin);

        return errorMetric;
    }

    // R SQUARED SCORE (R2)
    /**
    * Create new (online) R Square instance. This statistic measures how successful the fit is in explaining the variation of the data. Best possible score is 1.0, lower values are worse.
    * @class
    * @classdesc Online R Squared (R2) score instance
    * @param {module:fs.FIn} [FIn] - Saved state can be loaded via constructor
    * @extends module:analytics~createOnlineMetric
    */
    metrics.R2Score &#x3D; function (fin) {
        function metric() {
            this.name &#x3D; &quot;R2 Score&quot;
            this.shortName &#x3D; &quot;R2&quot;
            this.state &#x3D; {
                sst: 0,
                sse: 0,
                mean: 0,
                count: 0,
                sumTrue: 0,
                sumTrue2: 0,
                error: 0
            }
            // update function
            this.update &#x3D; function (yTrue, yPred) {
                this.state.count++;
                this.state.sumTrue +&#x3D; yTrue;
                this.state.sumTrue2 +&#x3D; yTrue * yTrue;
                this.state.mean &#x3D; this.state.sumTrue / this.state.count;
                //calculate R squared score
                this.state.sse +&#x3D; (yTrue - yPred) * (yTrue - yPred);
                this.state.sst &#x3D; this.state.sumTrue2 - this.state.count * this.state.mean * this.state.mean;
                if (this.state.sst &#x3D;&#x3D; 0.0) {
                    return (this.state.sse &#x3D;&#x3D; 0.0) ? 1.0 : 0.0;
                }
                this.state.error &#x3D; 1 - this.state.sse / this.state.sst;
                return this.state.error;
            }
        }
        // create new metric instance, and load state from fin in defined
        var errorMetric &#x3D; new createOnlineMetric(metric);
        if (typeof fin !&#x3D;&#x3D; &#x27;undefined&#x27;) errorMetric.load(fin);

        return errorMetric;
    }


    //////////////////////////////////////////////////
    //////////// BATCH REGRESSION METRICS ////////////
    //////////////////////////////////////////////////

    // function checks if input parameters are of appropriate type
    function checkBatchParams() {
        for (var i &#x3D; 0, j &#x3D; arguments.length; i &amp;lt; j; i++) {
            var argumentType &#x3D; arguments[i].constructor.name;
            if (argumentType !&#x3D;&#x3D; &quot;Array&quot; &amp;amp;&amp;amp; argumentType !&#x3D;&#x3D; &quot;Vector&quot;) {
                throw new TypeError(&#x27;input param &#x27; + i + &#x27; must be of type &quot;Array&quot; or &quot;Vector&quot;, but is &#x27; + argumentType + &#x27; instead&#x27;);
            }
        }
    }

    // calculate batch regression metrics
    function calcBatchError(yTrueVec, yPredVec) {
        // check input parameters
        checkBatchParams(yTrueVec, yPredVec);
        // calculate error with metric defined as callback functio
        function calcErr(metric) {
            // iterage over array of input data
            for (var i &#x3D; 0; i &amp;lt; yTrueVec.length; i++) {
                metric.push(yTrueVec[i], yPredVec[i]);
            }
            // return final error
            return metric.getError()
        }

        // expose metrics which will be used in calcErr() to return error
        this.ME &#x3D; function () { return calcErr(new metrics.MeanError()) };
        this.MAE &#x3D; function () { return calcErr(new metrics.MeanAbsoluteError()) };
        this.MSE &#x3D; function () { return calcErr(new metrics.MeanSquareError()) };
        this.RMSE &#x3D; function () { return calcErr(new metrics.RootMeanSquareError()) };
        this.MAPE &#x3D; function () { return calcErr(new metrics.MeanAbsolutePercentageError()) };
        this.R2 &#x3D; function () { return calcErr(new metrics.R2Score()) };
    };

    /**
    * Mean error (ME) regression loss.
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrueVec - ground truth values in &#x60;yTrueVec&#x60;
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPredVec - estimated values in &#x60;yPredVec&#x60;
    * @returns {number} Error value
    */
    metrics.meanError &#x3D; function (yTrueVec, yPredVec) {
        return new calcBatchError(yTrueVec, yPredVec).ME()
    }

    /**
    * Mean absolute error (MAE) regression loss.
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrueVec - ground truth values in &#x60;yTrueVec&#x60;
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPredVec - estimated values in &#x60;yPredVec&#x60;
    * @returns {number} Error value
    */
    metrics.meanAbsoluteError &#x3D; function (yTrueVec, yPredVec) {
        return new calcBatchError(yTrueVec, yPredVec).MAE()
    }

    /**
    * Mean square error (MSE) regression loss.
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrueVec - ground truth values in &#x60;yTrueVec&#x60;
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPredVec - estimated values in &#x60;yPredVec&#x60;
    * @returns {number} Error value
    */
    metrics.meanSquareError &#x3D; function (yTrueVec, yPredVec) {
        return new calcBatchError(yTrueVec, yPredVec).MSE()
    }

    /**
    * Root mean square (RMSE) error regression loss.
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrueVec - ground truth values in &#x60;yTrueVec&#x60;
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPredVec - estimated values in &#x60;yPredVec&#x60;
    * @returns {number} Error value
    */
    metrics.rootMeanSquareError &#x3D; function (yTrueVec, yPredVec) {
        return new calcBatchError(yTrueVec, yPredVec).RMSE()
    }

    /**
    * Mean absolute percentage error (MAPE) regression loss.
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrueVec - ground truth values in &#x60;yTrueVec&#x60;
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPredVec - estimated values in &#x60;yPredVec&#x60;
    * @returns {number} Error value
    */
    metrics.meanAbsolutePercentageError &#x3D; function (yTrueVec, yPredVec) {
        return new calcBatchError(yTrueVec, yPredVec).MAPE()
    }

    /**
    * R^2 (coefficient of determination) regression score.
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yTrueVec - ground truth values in &#x60;yTrueVec&#x60;
    * @param {(Array&amp;lt;number&gt; | module:la.Vector)} yPredVec - estimated values in &#x60;yPredVec&#x60;
    * @returns {number} Error value
    */
    metrics.r2Score &#x3D; function (yTrueVec, yPredVec) {
        return new calcBatchError(yTrueVec, yPredVec).R2()
    }

    // Exports metrics namespace
    exports.metrics &#x3D; metrics;

    /**
    * @typedef {Object} pcaParams
    * @property {number} [k &#x3D; null] - Number of eigenvectors to be computed.
    * @property {number} [iter &#x3D; 100] - Number of iterations.
    */

    /**
    * @classdesc Principal components analysis
    * @class
    * @param {module:analytics~pcaParams | module:fs.FIn} [params] - The constructor parameters.
    * @example &amp;lt;caption&gt;Using default constructor&amp;lt;/caption&gt;
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // construct model
    * var pca &#x3D; new analytics.PCA();
    * @example &amp;lt;caption&gt;Using custom constructor&amp;lt;/caption&gt;
    * // import analytics module
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * // construct model
    * var pca &#x3D; new analytics.PCA({ k: 5, iter: 50 });
    */
    exports.PCA &#x3D; function (param) {
        var iter, k;
        var initParam;
        this.P &#x3D; undefined;
        this.mu &#x3D; undefined;
        this.lambda &#x3D; undefined;
        var count &#x3D; 1;
        if (param !&#x3D; undefined &amp;amp;&amp;amp; param.constructor.name &#x3D;&#x3D; &#x27;FIn&#x27;) {
            this.P &#x3D; new la.Matrix();
            this.P.load(param);
            this.mu &#x3D; new la.Vector();
            this.mu.load(param);
            this.lambda &#x3D; new la.Vector();
            this.lambda.load(param);
            var params_vec &#x3D; new la.Vector();
            params_vec.load(param);
            iter &#x3D; params_vec[0];
            k &#x3D; params_vec[1];
        } else if (param &#x3D;&#x3D; undefined || typeof param &#x3D;&#x3D; &#x27;object&#x27;) {
            param &#x3D; param &#x3D;&#x3D; undefined ? {} : param;
            // Fit params
            var iter &#x3D; param.iter &#x3D;&#x3D; undefined ? 100 : param.iter;
            var k &#x3D; param.k; // can be undefined
        } else {
            throw &quot;PCA.constructor: parameter must be a JSON object or a fs.FIn!&quot;;
        }
        initParam &#x3D; { iter: iter, k: k };
        /**
        * Returns the model
        * @returns {Object} The model object whose keys are: P (eigenvectors), lambda (eigenvalues) and mu (mean)
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // create matrix
        * var matrix &#x3D; new la.Matrix([[0, 1], [-1, 0]]);
        * // fit matrix before getting the model
        * pca.fit(matrix)
        * // get your model using function getModel
        * var model &#x3D; pca.getModel();
        */
        this.getModel &#x3D; function () {
            return { P: this.P, mu: this.mu, lambda: this.lambda };
        }

        /**
        * Saves the model.
        * @param {module:fs.FOut} fout - The output stream.
        * @returns {module:fs.FOut} The given output stream fout.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // create matrix
        * var matrix &#x3D; new la.Matrix([[0, 1], [-1, 0]]);
        * // fit matrix
        * pca.fit(matrix);
        * var model &#x3D; pca.getModel();
        * // save model
        * pca.save(require(&#x27;qminer&#x27;).fs.openWrite(&#x27;pca_test.bin&#x27;)).close();
        */
        this.save &#x3D; function (fout) {
            if (!this.P) {
                throw new Error(&quot;PCA.save() - model not created yet&quot;);
            }

            var params_vec &#x3D; new la.Vector();
            params_vec.push(iter);
            params_vec.push(k);
            
            if (fout.constructor.name &#x3D;&#x3D; &#x27;FOut&#x27;) {
                this.P.save(fout);
                this.mu.save(fout);
                this.lambda.save(fout);
                params_vec.save(fout);
                return fout;
            } else {
                throw &quot;PCA.save: input must be fs.FOut&quot;;
            }
        }
        

        /**
        * Sets parameters
        * @param {p} Object whose keys are: k (number of eigenvectors) and iter (maximum iterations)
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // set 5 eigenvectors and 10 iterations using setParams
        * pca.setParams({iter: 10, k: 5});
        */
        this.setParams &#x3D; function (param) {
            iter &#x3D; param.iter &#x3D;&#x3D; undefined ? iter : param.iter;
            k &#x3D; param.k &#x3D;&#x3D; undefined ? k : param.k;
            initParam &#x3D; { iter: iter, k: k };
        }

        /**
        * Gets parameters
        * @returns Object whose keys are: k (number of eigenvectors) and iter (maximum iterations)
        * @example &amp;lt;caption&gt;Using default constructor&amp;lt;/caption&gt;
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // check the constructor parameters
        * var paramvalue &#x3D; pca.getParams();
        * @example &amp;lt;caption&gt;Using custom constructor&amp;lt;/caption&gt;
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // set parameters
        * pca.setParams({iter: 10, k: 5});
        * // check the changed parameters
        * var paramvalue &#x3D; pca.getParams();
        */
        this.getParams &#x3D; function () {
            return initParam;
        }

        /**
        * Finds the eigenvectors of the variance matrix.
        * @param {module:la.Matrix} A - Matrix whose columns correspond to examples.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // create matrix
        * var matrix &#x3D; new la.Matrix([[0, 1], [-1, 0]]);
        * // fit the matrix
        * pca.fit(matrix);
        */
        this.fit &#x3D; function (A) {
            var rows &#x3D; A.rows;
            var cols &#x3D; A.cols;

            k &#x3D; k &#x3D;&#x3D; undefined ? rows : k;
            //iter &#x3D; iter &#x3D;&#x3D; undefined ? -1 : iter;

            var mu &#x3D; stat.mean(A, 2);
            // cov(A) &#x3D; 1/(n-1) A A&#x27; - mu mu&#x27;

            // center data (same as matlab)
            var cA &#x3D; A.minus(mu.outer(la.ones(cols)));
            var C &#x3D; cA.multiply(cA.transpose()).multiply(1 / (cols - 1));
            // alternative computation:
            //var C &#x3D; (A.multiply(A.transpose()).multiply(1 / (cols - 1))).minus(mu.outer(mu));
            var res &#x3D; la.svd(C, k, { iter: iter });

            this.P &#x3D; res.U;
            this.lambda &#x3D; res.s;
            this.mu &#x3D; mu;
        }

        /**
        * Projects the example(s) and expresses them as coefficients in the eigenvector basis this.P.
        * Recovering the data in the original space: (this.P).multiply(p), where p&#x27;s rows are the coefficients
        * in the eigenvector basis.
        * @param {(module:la.Vector | module:la.Matrix)} x - Test vector or matrix with column examples
        * @returns {(module:la.Vector | module:la.Matrix)} Returns projected vector or matrix
        * @example &amp;lt;caption&gt;Transforming the matrix&amp;lt;/caption&gt;
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // create matrix
        * var matrix &#x3D; new la.Matrix([[0, 1], [-1, 0]]);
        * // fit the matrix
        * pca.fit(matrix);
        * var model &#x3D; pca.getModel();
        * // transform matrix
        * var transform &#x3D; pca.transform(matrix);
        * @example &amp;lt;caption&gt;Transforming the vector&amp;lt;/caption&gt;
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // create vector you wish to transform
        * var vector &#x3D; new la.Vector([0, -1]);
        * // create matrix
        * var matrix &#x3D; new la.Matrix([[0, 1], [-1, 0]]);
        * // fit the matrix
        * pca.fit(matrix);
        * var model &#x3D; pca.getModel();
        * // transform vector
        * var transform &#x3D; pca.transform(vector);
        */
        this.transform &#x3D; function (x) {
            if (x.constructor.name &#x3D;&#x3D; &#x27;Matrix&#x27;) {
                // P * (x - mu*ones(1, size(x,2)))
                return this.P.multiplyT(x.minus(this.mu.outer(la.ones(x.cols))));

            } else if (x.constructor.name &#x3D;&#x3D; &#x27;Vector&#x27;) {
                // P * (x - mu)
                return this.P.multiplyT(x.minus(this.mu));
            }
        }

        /**
        * Reconstructs the vector in the original space, reverses centering
        * @param {(module:la.Vector | module:la.Matrix)} x - Test vector or matrix with column examples, in the PCA space
        * @returns {(module:la.Vector | module:la.Matrix)} Returns the reconstruction
        * @example &amp;lt;caption&gt;Inverse transform of matrix&amp;lt;/caption&gt;
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // create matrix
        * var matrix &#x3D; new la.Matrix([[0, 1], [-1, 0]]);
        * // fit the matrix
        * pca.fit(matrix);
        * var model &#x3D; pca.getModel();
        * // use inverseTransform on matrix
        * var invTransform &#x3D; pca.inverseTransform(matrix);
        * @example &amp;lt;caption&gt;Inverse transform of vector&amp;lt;/caption&gt;
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // construct model
        * var pca &#x3D; new analytics.PCA();
        * // create vector
        * var vector &#x3D; new la.Vector([0, -1]);
        * // create matrix
        * var matrix &#x3D; new la.Matrix([[0, 1], [-1, 0]]);
        * // fit the matrix
        * pca.fit(matrix);
        * var model &#x3D; pca.getModel();
        * // use inverseTransform on vector
        * var invTransform &#x3D; pca.inverseTransform(vector);
        */
        this.inverseTransform &#x3D; function (x) {
            if (x.constructor.name &#x3D;&#x3D; &#x27;Matrix&#x27;) {
                // P x + mu*ones(1, size(x,2)
                return (this.P.multiply(x)).plus(this.mu.outer(la.ones(x.cols)));
            } else if (x.constructor.name &#x3D;&#x3D; &#x27;Vector&#x27;) {
                // P x + mu
                return (this.P.multiply(x)).plus(this.mu);
            }
        }
    }

    /**
    * @classdesc KMeans clustering
    * @class
    * @property {number} iter - The maximum number of iterations.
    * @property {number} k - The number of centroids.
    * @property {boolean} verbose - If false, the console output is supressed.
    * @property {Array} fitIdx - Array of indexes that should be used as starting centroids. Optional.
    * @property {model} fitStart - Model from another KMeans algorithm (obtained via getModel() method). Its centroids are used as starting centroids for this model. Optional.
    * @example
    * // import analytics and la modules
    * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a KMeans object
    * var KMeans &#x3D; new analytics.KMeans();
    * // create the matrix to be fitted
    * var X &#x3D; new la.Matrix([[1, -2, -1], [1, 1, -3]]);
    * // create the model
    * KMeans.fit(X);
    */
    exports.KMeans &#x3D; function (param) {

        // Fit params
        // var iter &#x3D; param.iter &#x3D;&#x3D; undefined ? 100 : param.iter;
        // var k &#x3D; param.k &#x3D;&#x3D; undefined ? 2 : param.k;
        // var verbose &#x3D; param.verbose &#x3D;&#x3D; undefined ? false : param.verbose;
        // var fitIdx &#x3D; param.fitIdx &#x3D;&#x3D; undefined ? undefined : param.fitIdx;

        // Model
        var C &#x3D; undefined;
        var idxv &#x3D; undefined;
        var norC2 &#x3D; undefined;
        var iter &#x3D; undefined;
        var k &#x3D; undefined;
        var verbose &#x3D; undefined;
        var fitIdx &#x3D; undefined;
        var fitStart &#x3D; undefined;
        var medoids &#x3D; new la.Vector();

        if (param !&#x3D; undefined &amp;amp;&amp;amp; param instanceof fs.FIn) {
		    C &#x3D; new la.Matrix(); C.load(param);
		    norC2 &#x3D; new la.Vector(); norC2.load(param);
		    idxv &#x3D; new la.IntVector(); idxv.load(param);
		    var fin_params &#x3D; param.readJson();
		    iter &#x3D; fin_params.iter;
		    k &#x3D; fin_params.k;
		    verbose &#x3D; fin_params.verbose;
		    medoids.load(param);
	    } else if (param &#x3D;&#x3D; undefined || typeof param &#x3D;&#x3D; &#x27;object&#x27;) {
            param &#x3D; param &#x3D;&#x3D; undefined ? {} : param;
            // Fit params
            iter &#x3D; (param.iter &#x3D;&#x3D; undefined) ? 100 : param.iter;
            k &#x3D; (param.k &#x3D;&#x3D; undefined) ? 2 : param.k;
            verbose &#x3D; (param.verbose &#x3D;&#x3D; undefined) ? false : param.verbose;
            fitIdx &#x3D; param.fitIdx &#x3D;&#x3D; undefined ? undefined : param.fitIdx;
            fitStart &#x3D; param.fitStart &#x3D;&#x3D; undefined ? undefined : param.fitStart;
        } else {
            throw &quot;KMeans.constructor: parameter must be a JSON object or a fs.FIn!&quot;;
        }
        param &#x3D; { iter: iter, k: k, verbose: verbose };

        /**
        * Permutes centroid with given mapping.
        * @param {object} mapping - object that contains the mapping. E.g. mapping[4]&#x3D;2 means &quot;map cluster 4 into cluster 2&quot;
        */
        this.permuteCentroids &#x3D; function (mapping) {
            var cl_count &#x3D; C.cols;
            var perm_matrix &#x3D; la.zeros(cl_count, cl_count);
            for (var i &#x3D; 0; i &amp;lt; cl_count; i++) {
                perm_matrix.put(i, mapping[i], 1);
            }
            var C_new &#x3D; C.multiply(perm_matrix);
            var idxv_new &#x3D; new la.Vector(idxv);
            for (var i &#x3D; 0; i &amp;lt; idxv_new.length; i++) {
                idxv_new[i] &#x3D; mapping[idxv[i]]
            }
            C &#x3D; C_new;
            norC2 &#x3D; la.square(C.colNorms());
            idxv &#x3D; idxv_new;
            if (medoids.length !&#x3D; 0) {
                var medoids_new &#x3D; new la.Vector(medoids);
                for (var i &#x3D; 0; i &amp;lt; medoids_new.length; i++) {
                    medoids_new[i] &#x3D; mapping[medoids[i]]
                }
                medoids &#x3D; medoids_new;
            }
        }
        /**
        * Returns the model
        * @returns {Object} The model object whose keys are: C (centroids) and idxv (cluster ids of the training data).
        * @example
        * // import modules
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * var la &#x3D; require(&#x27;qminer&#x27;).la;
        * // create the KMeans object
        * var KMeans &#x3D; new analytics.KMeans({ iter: 1000 });
        * // create a matrix to be fitted
        * var X &#x3D; new la.Matrix([[1, -2, -1], [1, 1, -3]]);
        * // create the model
        * KMeans.fit(X);
        * // get the model
        * var model &#x3D; KMeans.getModel();
        */
        this.getModel &#x3D; function () {
            return { C: C, idxv: idxv };
        }

        /**
        * Sets the parameters.
        * @param {Object} p - Object whose keys are: k (number of centroids), iter (maximum iterations) and verbose (if false, console output is supressed).
        * @returns {module:analytics.KMeans} Self.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // create a new KMeans object
        * var KMeans &#x3D; new analytics.KMeans();
        * // change the parameters of the KMeans object
        * KMeans.setParams({ iter: 1000, k: 5 });
        */
        this.setParams &#x3D; function (p) {
            param &#x3D; p;

            iter &#x3D; param.iter &#x3D;&#x3D; undefined ? iter : param.iter;
            k &#x3D; param.k &#x3D;&#x3D; undefined ? k : param.k;
            verbose &#x3D; param.verbose &#x3D;&#x3D; undefined ? verbose : param.verbose;
            fitIdx &#x3D; param.fitIdx &#x3D;&#x3D; undefined ? fitIdx : param.fitIdx;
            fitStart &#x3D; param.fitStart &#x3D;&#x3D; undefined ? undefined : param.fitStart;
        }

        /**
        * Returns the parameters.
        * @returns Object whose keys are: k (number of centroids), iter (maximum iterations) and verbose (if false, console output is supressed).
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // create a new KMeans object
        * var KMeans &#x3D; new analytics.KMeans({ iter: 1000, k: 5 });
        * // get the parameters
        * var json &#x3D; KMeans.getParams();
        */
        this.getParams &#x3D; function () {
            return  { iter: iter, k: k, verbose: verbose }
        }

        /**
        * Computes the centroids.
        * @param {(module:la.Matrix | module:la.SparseMatrix)} X - Matrix whose columns correspond to examples.
        * @param {module:la.IntVector} [recIds] - IDs of columns of X. The fit function stores the IDs of the medoids, which are used by the KMeans.explain function.
        * @returns {module:analytics.KMeans} Self. It stores the info about the new model.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // create a new KMeans object
        * var KMeans &#x3D; new analytics.KMeans({ iter: 1000, k: 3 });
        * // create a matrix to be fitted
        * var X &#x3D; new la.Matrix([[1, -2, -1], [1, 1, -3]]);
        * // create the model with the matrix X
        * KMeans.fit(X);
        */
        this.fit &#x3D; function (X, recIds) {
            // select random k columns of X, returns a dense C++ matrix
            var selectCols &#x3D; function (X, k) {
                if (fitStart) {
                    assert(fitStart.C.cols &#x3D;&#x3D; k, &quot;Error: fitStart.C.cols is not of length k!&quot;);
					var result &#x3D; {};
					result.C &#x3D; fitStart.C;
					result.idx &#x3D; la.randi(X.cols, k); // this assignment is irrelevant, really
					return result;
				}
				var idx;
				if (fitIdx &#x3D;&#x3D; undefined) {
					idx &#x3D; la.randi(X.cols, k);
				} else {
					assert(fitIdx.length &#x3D;&#x3D; k, &quot;Error: fitIdx is not of length k!&quot;);
					assert(Math.max.apply(Math, fitIdx) &amp;lt; X.cols, &quot;Error: fitIdx contains index greater than number of columns in matrix. Index out of range!&quot;);
					idx &#x3D; fitIdx;
				}
				var idxMat &#x3D; new la.SparseMatrix({ cols: 0, rows: X.cols });
				for (var i &#x3D; 0; i &amp;lt; idx.length; i++) {
					var spVec &#x3D; new la.SparseVector([[idx[i], 1.0]], X.cols);
					idxMat.push(spVec);
				}
                var C &#x3D; X.multiply(idxMat);
                var result &#x3D; {};
                result.C &#x3D; C;
                result.idx &#x3D; idx;
                return result;
            };

            // modified k-means algorithm that avoids empty centroids
            // A Modified k-means Algorithm to Avoid Empty Clusters, Malay K. Pakhira
            // http://www.academypublisher.com/ijrte/vol01/no01/ijrte0101220226.pdf
            var getCentroids &#x3D; function (X, idx, oldC) {
                // select random k columns of X, returns a dense matrix
                // 1. construct a sparse matrix (coordinate representation) that encodes the closest centroids
                var idxvec &#x3D; new la.IntVector(idx);
                var rangeV &#x3D; la.rangeVec(0, X.cols - 1);
                var ones_cols &#x3D; la.ones(X.cols);
                var idxMat &#x3D; new la.SparseMatrix(idxvec, rangeV, ones_cols, X.cols);
                idxMat &#x3D; idxMat.transpose();
                var ones_n &#x3D; la.ones(X.cols);
                // 2. compute the number of points that belong to each centroid, invert
                var colSum &#x3D; idxMat.multiplyT(ones_n);
                for (var i &#x3D; 0; i &amp;lt; colSum.length; i++) {
                    var val &#x3D; 1.0 / (1.0 + colSum.at(i)); // modification
                    colSum.put(i, val);
                }
                // 3. compute the centroids
                //var w &#x3D; new qm_util.clsStopwatch();
                //w.tic();
                var sD &#x3D; colSum.spDiag();
                var C &#x3D; oldC;
                if (idxMat.cols &#x3D;&#x3D; oldC.cols)
                    C &#x3D; ((X.multiply(idxMat)).plus(oldC)).multiply(sD); // modification
                return C;
            };


            // X: column examples
            // k: number of centroids
            // iter: number of iterations
            assert(k &amp;lt;&#x3D; X.cols, &quot;k &amp;lt;&#x3D; X.cols&quot;);
            var w &#x3D; new qm_util.clsStopwatch();
            var norX2 &#x3D; la.square(X.colNorms());
            var initialCentroids &#x3D; selectCols(X, k);
            C &#x3D; initialCentroids.C;
            var idxvOld &#x3D; initialCentroids.idx;
            //printArray(idxvOld); // DEBUG
            var ones_n &#x3D; la.ones(X.cols).multiply(0.5);
            var ones_k &#x3D; la.ones(k).multiply(0.5);
            w.tic();
            for (var i &#x3D; 0; i &amp;lt; iter; i++) {
                //console.say(&quot;iter: &quot; + i);
                norC2 &#x3D; la.square(C.colNorms());
                //D &#x3D;  full(C&#x27;* X) - norC2&#x27; * (0.5* ones(1, n)) - (0.5 * ones(k,1) )* norX2&#x27;;
                var D &#x3D; C.multiplyT(X).minus(norC2.outer(ones_n)).minus(ones_k.outer(norX2));
                idxv &#x3D; new la.IntVector(la.findMaxIdx(D));

                if (verbose) {
                    var energy &#x3D; 0.0;
                    for (var j &#x3D; 0; j &amp;lt; X.cols; j++) {
                        if (D.at(idxv[j], j) &amp;lt; 0) {
                            energy +&#x3D; Math.sqrt(-2 * D.at(idxv[j], j));
                        }
                    }
                    console.log(&quot;energy: &quot; + 1.0 / X.cols * energy);
                }
                if (qm_util.arraysIdentical(idxv, idxvOld)) {
                    if (verbose) {
                        console.log(&quot;converged at iter: &quot; + i); //DEBUG
                    }
                    break;
                }
                idxvOld &#x3D; new la.IntVector(idxv);
                C &#x3D; getCentroids(X, idxv, C); //drag
            }
            if (verbose) {
                w.toc(&quot;end&quot;);
            }
            norC2 &#x3D; la.square(C.colNorms());
            if (recIds !&#x3D; undefined) {
                assert(recIds.length &#x3D;&#x3D; X.cols);
                var D &#x3D; X.multiplyT(C).minus(ones_n.outer(norC2)).minus(norX2.outer(ones_k));
                medoidIdx &#x3D; la.findMaxIdx(D);
                medoids &#x3D; new la.Vector(medoidIdx);
                for (var i &#x3D; 0; i &amp;lt; medoids.length; i++) {
                    medoids[i] &#x3D; recIds[medoidIdx[i]];
                }
            }
        };

        /**
        * Returns an vector of cluster id assignments.
        * @param {(module:la.Matrix | module:la.SparseMatrix)} A - Matrix whose columns correspond to examples.
        * @returns {module:la.IntVector} Vector of cluster assignments.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // create a new KMeans object
        * var KMeans &#x3D; new analytics.KMeans({ iter: 1000, k: 3 });
        * // create a matrix to be fitted
        * var X &#x3D; new la.Matrix([[1, -2, -1], [1, 1, -3]]);
        * // create the model with the matrix X
        * KMeans.fit(X);
        * // create the matrix of the prediction vectors
        * var pred &#x3D; new la.Matrix([[2, -1, 1], [1, 0, -3]]);
        * // predict the values
        * var prediction &#x3D; KMeans.predict(pred);
        */
        this.predict &#x3D; function (X) {
            var ones_n &#x3D; la.ones(X.cols).multiply(0.5);
            var ones_k &#x3D; la.ones(k).multiply(0.5);
            var norX2 &#x3D; la.square(X.colNorms());
            var D &#x3D; C.multiplyT(X).minus(norC2.outer(ones_n)).minus(ones_k.outer(norX2));
            return la.findMaxIdx(D);
        }

        /**
        * @typedef KMeansExplanation
        * @type {Object}
        * @property {number} medoidID - The ID of the nearest medoids
        * @property {module:la.IntVector} featureIDs - The IDs of features, sorted by contribution
        * @property {module:la.Vector} featureContributions - Weights of each feature contribution (sum to 1.0)
        */

        /**
        * Returns the IDs of the nearest medoid for each example.
        * @param {(module:la.Matrix | module:la.SparseMatrix)} X - Matrix whose columns correspond to examples.
        * @returns {Array.&amp;lt;KMeansExplanation&gt;} Object containing the vector of medoid IDs.
        * @example
        * // import analytics module
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * // import linear algebra module
        * var la &#x3D; require(&#x27;qminer&#x27;).la;
        * // create a new KMeans object
        * var KMeans &#x3D; new analytics.KMeans({ iter: 1000, k: 3 });
        * // create a matrix to be fitted
        * var X &#x3D; new la.Matrix([[1, -2, -1], [1, 1, -3]]);
        * // create the model with the matrix X using the column IDs [0,1,2]
        * KMeans.fit(X, [1234,1142,2355]);
        * // create the matrix of the prediction vectors
        * var test &#x3D; new la.Matrix([[2, -1, 1], [1, 0, -3]]);
        * // predict/explain - return the closest medoids
        * var explanation &#x3D; KMeans.explain(test);
        */
        this.explain &#x3D; function (X) {
            if (medoids &#x3D;&#x3D; undefined) {
                return { medoidIDs: null };
            }
            var ones_n &#x3D; la.ones(X.cols).multiply(0.5);
            var ones_k &#x3D; la.ones(k).multiply(0.5);
            var norX2 &#x3D; la.square(X.colNorms());
            var D &#x3D; C.multiplyT(X).minus(norC2.outer(ones_n)).minus(ones_k.outer(norX2));
            var centroids &#x3D; la.findMaxIdx(D);
            var medoidIDs &#x3D; new la.IntVector(centroids);
            assert(medoids.length &#x3D;&#x3D; k);
            var result &#x3D; [];
            for (var i &#x3D; 0; i &amp;lt; centroids.length; i++) {
                var explanation &#x3D; featureContrib(X.getCol(i), C.getCol(centroids[i]));
                result[i] &#x3D; {
                    medoidID: medoids[centroids[i]],
                    featureIDs: explanation.featureIDs,
                    featureContributions: explanation.featureContributions
                }
            }
            return result;
        }

        /**
        * Returns the weights and feature IDs that contributed to the distance between two vectors
        * @param {(module:la.Vector | module:la.SparseVector)} x - Vector
        * @param {(module:la.Vector | module:la.SparseVector)} y - Vector
        * @returns {Object} Feature IDs and feature contributions
        **/
        function featureContrib(x, y) {
            var fx &#x3D; x.constructor.name &#x3D;&#x3D; &#x27;SparseVector&#x27; ? x.full() : x;
            var fy &#x3D; y.constructor.name &#x3D;&#x3D; &#x27;SparseVector&#x27; ? y.full() : y;
            var diff &#x3D; fx.minus(fy);
            var nor2 &#x3D; Math.pow(diff.norm(), 2);
            for (var i &#x3D; 0; i &amp;lt; diff.length; i++) {
                diff[i] &#x3D; Math.pow(diff[i], 2) / nor2;
            }
            var sorted &#x3D; diff.sortPerm(false); // sort descending
            return { featureIDs: sorted.perm, featureContributions: sorted.vec };
        }

        /**
        * Transforms the points to vectors of squared distances to centroids.
        * @param {(module:la.Matrix | module:la.SparseMatrix)} A - Matrix whose columns correspond to examples.
        * @returns {module:la.Matrix} Matrix where each column represents the squared distances to the centroid vectors.
        * @example
        * // import modules
        * var analytics &#x3D; require(&#x27;qminer&#x27;).analytics;
        * var la &#x3D; require(&#x27;qminer&#x27;).la;
        * // create a new KMeans object
        * var KMeans &#x3D; new analytics.KMeans({ iter: 1000, k: 3 });
        * // create a matrix to be fitted
        * var X &#x3D; new la.Matrix([[1, -2, -1], [1, 1, -3]]);
        * // create the model with the matrix X
        * KMeans.fit(X);
        * // create the matrix of the transform vectors
        * var matrix &#x3D; new la.Matrix([[-2, 0], [0, -3]]);
        * // get the transform values of matrix
        * // returns the matrix
        * //  10    17
        * //   1    20
        * //  10     1
        * KMeans.transform(matrix);
        */
        this.transform &#x3D; function (X) {
            var ones_n &#x3D; la.ones(X.cols).multiply(0.5);
            var ones_k &#x3D; la.ones(k).multiply(0.5);
            var norX2 &#x3D; la.square(X.colNorms());
            var D &#x3D; C.multiplyT(X).minus(norC2.outer(ones_n)).minus(ones_k.outer(norX2));
            D &#x3D; D.multiply(-2);
            return D;
        }
		/**
        * Saves KMeans internal state into (binary) file.
        * @param {module:fs.FOut} arg - The output stream.
        * @returns {module:fs.FOut} The output stream fout.
        */
        this.save &#x3D; function (fout) {
			if (!C) { throw new Error(&quot;KMeans.save() - model not created yet&quot;); }
			C.save(fout);
            norC2.save(fout);
            idxv.save(fout);
            fout.writeJson({
				iter: iter,
				k: k,
				verbose: verbose
			});
			medoids.save(fout);
            return fout;
		}
    }

    function defarg(arg, defaultval) {
        return arg &#x3D;&#x3D; undefined ? defaultval : arg;
    }

    ///////////////////////////////
    ////// code below not yet ported or verified for scikit
    ///////////////////////////////

    //!- &#x60;alModel &#x3D; analytics.newActiveLearner(query, qRecSet, fRecSet, ftrSpace, settings)&#x60; -- initializes the
    //!    active learning. The algorihm is run by calling &#x60;model.startLoop()&#x60;. The algorithm has two stages: query mode, where the algorithm suggests potential
    //!    positive and negative examples based on the query text, and SVM mode, where the algorithm keeps
    //!   selecting examples that are closest to the SVM margin (every time an example is labeled, the SVM
    //!   is retrained.
    //!   The inputs are: query (text), record set &#x60;qRecSet&#x60;, record set &#x60;fRecSet&#x60;,  the feature space &#x60;ftrSpace&#x60; and a
    //!   &#x60;settings&#x60;JSON object. The settings object specifies:&#x60;textField&#x60; (string) which is the name
    //!    of the field in records that is used to create feature vectors, &#x60;nPos&#x60; (integer) and &#x60;nNeg&#x60; (integer) set the number of positive and negative
    //!    examples that have to be identified in the query mode before the program enters SVM mode.
    //!   We can set two additional parameters &#x60;querySampleSize&#x60; and &#x60;randomSampleSize&#x60; which specify the sizes of subsamples of qRecSet and fRecSet, where the rest of the data is ignored in the active learning.
    //!   Final parameters are all SVM parameters (c, j, batchSize, maxIterations, maxTime, minDiff, verbose).
    exports.newActiveLearner &#x3D; function (query, qRecSet, fRecSet, ftrSpace, stts) {
        return new exports.ActiveLearner(query, qRecSet, fRecSet, ftrSpace, stts);
    }

    exports.ActiveLearner &#x3D; function (query, qRecSet, fRecSet, ftrSpace, stts) {
        var settings &#x3D; defarg(stts, {});
        settings.nPos &#x3D; defarg(stts.nPos, 2);
        settings.nNeg &#x3D; defarg(stts.nNeg, 2);
        settings.textField &#x3D; defarg(stts.textField, &quot;Text&quot;);
        settings.querySampleSize &#x3D; defarg(stts.querySampleSize, -1);
        settings.randomSampleSize &#x3D; defarg(stts.randomSampleSize, -1);
        settings.c &#x3D; defarg(stts.c, 1.0);
        settings.j &#x3D; defarg(stts.j, 1.0);
        settings.batchSize &#x3D; defarg(stts.batchSize, 100);
        settings.maxIterations &#x3D; defarg(stts.maxIterations, 100000);
        settings.maxTime &#x3D; defarg(stts.maxTime, 1); // 1 second for computation by default
        settings.minDiff &#x3D; defarg(stts.minDiff, 1e-6);
        settings.verbose &#x3D; defarg(stts.verbose, false);

        // compute features or provide them
        settings.extractFeatures &#x3D; defarg(stts.extractFeatures, true);

        if (!settings.extractFeatures) {
            if (stts.uMat &#x3D;&#x3D; null) { throw &#x27;settings uMat not provided, extractFeatures &#x3D; false&#x27;; }
            if (stts.uRecSet &#x3D;&#x3D; null) { throw &#x27;settings uRecSet not provided, extractFeatures &#x3D; false&#x27;; }
            if (stts.querySpVec &#x3D;&#x3D; null) { throw &#x27;settings querySpVec not provided, extractFeatures &#x3D; false&#x27;; }
        }

        // QUERY MODE
        var queryMode &#x3D; true;
        // bow similarity between query and training set

        var querySpVec;
        var uRecSet;
        var uMat;

        if (settings.extractFeatures) {
            var temp &#x3D; {}; temp[settings.textField] &#x3D; query;
            var queryRec &#x3D; qRecSet.store.newRecord(temp); // record
            querySpVec &#x3D; ftrSpace.extractSparseVector(queryRec);
            // use sampling?
            var sq &#x3D; qRecSet;
            if (settings.querySampleSize &gt;&#x3D; 0 &amp;amp;&amp;amp; qRecSet !&#x3D; undefined) {
                sq &#x3D; qRecSet.sample(settings.querySampleSize);
            }
            var sf &#x3D; fRecSet;
            if (settings.randomSampleSize &gt;&#x3D; 0 &amp;amp;&amp;amp; fRecSet !&#x3D; undefined) {
                sf &#x3D; fRecSet.sample(settings.randomSampleSize);
            }
            // take a union or just qset or just fset if some are undefined
            uRecSet &#x3D; (sq !&#x3D; undefined) ? ((sf !&#x3D; undefined) ? sq.setunion(sf) : sq) : sf;
            if (uRecSet &#x3D;&#x3D; undefined) { throw &#x27;undefined record set for active learning!&#x27;;}
            uMat &#x3D; ftrSpace.extractSparseMatrix(uRecSet);

        } else {
            querySpVec &#x3D; stts.querySpVec;
            uRecSet &#x3D; stts.uRecSet;
            uMat &#x3D; stts.uMat;
        }


        querySpVec.normalize();
        uMat.normalizeCols();

        var X &#x3D; new la.SparseMatrix();
        var y &#x3D; new la.Vector();
        var simV &#x3D; uMat.multiplyT(querySpVec); //similarities (q, recSet)
        var sortedSimV &#x3D; simV.sortPerm(); //ascending sort
        var simVs &#x3D; sortedSimV.vec; //sorted similarities (q, recSet)
        var simVp &#x3D; sortedSimV.perm; //permutation of sorted similarities (q, recSet)
        //// counters for questions in query mode
        var nPosQ &#x3D; 0; //for traversing simVp from the end
        var nNegQ &#x3D; 0; //for traversing simVp from the start


        // SVM MODE
        var svm;
        var posIdxV &#x3D; new la.IntVector(); //indices in recordSet
        var negIdxV &#x3D; new la.IntVector(); //indices in recordSet

        var posRecIdV &#x3D; new la.IntVector(); //record IDs
        var negRecIdV &#x3D; new la.IntVector(); //record IDs

        var classVec &#x3D; new la.Vector({ &quot;vals&quot;: uRecSet.length }); //svm scores for record set
        var resultVec &#x3D; new la.Vector({ &quot;vals&quot;: uRecSet.length }); // non-absolute svm scores for record set


        //!   - &#x60;rs &#x3D; alModel.getRecSet()&#x60; -- returns the record set that is being used (result of sampling)
        this.getRecSet &#x3D; function () { return uRecSet };

        //!   - &#x60;idx &#x3D; alModel.selectedQuestionIdx()&#x60; -- returns the index of the last selected question in alModel.getRecSet()
        this.selectedQuestionIdx &#x3D; -1;

        //!   - &#x60;bool &#x3D; alModel.getQueryMode()&#x60; -- returns true if in query mode, false otherwise (SVM mode)
        this.getQueryMode &#x3D; function () { return queryMode; };

        //!   - &#x60;numArr &#x3D; alModel.getPos(thresh)&#x60; -- given a &#x60;threshold&#x60; (number) return the indexes of records classified above it as a javascript array of numbers. Must be in SVM mode.
        this.getPos &#x3D; function (threshold) {
            if (this.queryMode) { return null; } // must be in SVM mode to return results
            if (!threshold) { threshold &#x3D; 0; }
            var posIdxArray &#x3D; [];
            for (var recN &#x3D; 0; recN &amp;lt; uRecSet.length; recN++) {
                if (resultVec[recN] &gt;&#x3D; threshold) {
                    posIdxArray.push(recN);
                }
            }
            return posIdxArray;
        };

        this.debug &#x3D; function () { debugger; }

        this.getTop &#x3D; function (limit) {
            if (this.queryMode) { return null; } // must be in SVM mode to return results
            if (!limit) { limit &#x3D; 20; }
            var idxArray &#x3D; [];
            var marginArray &#x3D; [];
            var sorted &#x3D; resultVec.sortPerm(false);
            for (var recN &#x3D; 0; recN &amp;lt; uRecSet.length &amp;amp;&amp;amp; recN &amp;lt; limit; recN++) {
                idxArray.push(sorted.perm[recN]);
                var val &#x3D; sorted.vec[recN];
                val &#x3D; val &#x3D;&#x3D; Number.POSITIVE_INFINITY ? Number.MAX_VALUE : val;
                val &#x3D; val &#x3D;&#x3D; Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : val;
                marginArray.push(val);
            }
            return { posIdx: idxArray, margins: marginArray };
        };

        //!   - &#x60;objJSON &#x3D; alModel.getSettings()&#x60; -- returns the settings object
        this.getSettings &#x3D; function () { return settings; }

        // returns record set index of the unlabeled record that is closest to the margin
        //!   - &#x60;recSetIdx &#x3D; alModel.selectQuestion()&#x60; -- returns &#x60;recSetIdx&#x60; - the index of the record in &#x60;recSet&#x60;, whose class is unknonw and requires user input
        this.selectQuestion &#x3D; function () {
            if (posRecIdV.length &gt;&#x3D; settings.nPos &amp;amp;&amp;amp; negRecIdV.length &gt;&#x3D; settings.nNeg) { queryMode &#x3D; false; }
            if (queryMode) {
                if (posRecIdV.length &amp;lt; settings.nPos &amp;amp;&amp;amp; nPosQ + 1 &amp;lt; uRecSet.length) {
                    nPosQ &#x3D; nPosQ + 1;
                    console.log(&quot;query mode, try to get pos&quot;);
                    this.selectedQuestionIdx &#x3D; simVp[simVp.length - 1 - (nPosQ - 1)];
                    return this.selectedQuestionIdx;
                }
                if (negRecIdV.length &amp;lt; settings.nNeg &amp;amp;&amp;amp; nNegQ + 1 &amp;lt; uRecSet.length) {
                    nNegQ &#x3D; nNegQ + 1;
                    // TODO if nNegQ &#x3D;&#x3D; rRecSet.length, find a new sample
                    console.log(&quot;query mode, try to get neg&quot;);
                    this.selectedQuestionIdx &#x3D; simVp[nNegQ - 1];
                    return this.selectedQuestionIdx;
                }
            }
            else {
                ////call svm, get record closest to the margin
                svm &#x3D; new exports.SVC(settings);
                svm.fit(X, y);//column examples, y float vector of +1/-1, default svm paramvals

                // mark positives
                for (var i &#x3D; 0; i &amp;lt; posIdxV.length; i++) {
                    classVec[posIdxV[i]] &#x3D; Number.POSITIVE_INFINITY;
                    resultVec[posIdxV[i]] &#x3D; Number.POSITIVE_INFINITY;
                }
                // mark negatives
                for (var i &#x3D; 0; i &amp;lt; negIdxV.length; i++) {
                    classVec[negIdxV[i]] &#x3D; Number.POSITIVE_INFINITY;
                    resultVec[negIdxV[i]] &#x3D; Number.NEGATIVE_INFINITY;
                }
                var posCount &#x3D; posIdxV.length;
                var negCount &#x3D; negIdxV.length;
                // classify unlabeled
                for (var recN &#x3D; 0; recN &amp;lt; uRecSet.length; recN++) {
                    if (classVec[recN] !&#x3D;&#x3D; Number.POSITIVE_INFINITY) {
                        var svmMargin &#x3D; svm.predict(uMat.getCol(recN));
                        if (svmMargin &gt; 0) {
                            posCount++;
                        } else {
                            negCount++;
                        }
                        classVec[recN] &#x3D; Math.abs(svmMargin);
                        resultVec[recN] &#x3D; svmMargin;
                    }
                }
                var sorted &#x3D; classVec.sortPerm();
                console.log(&quot;svm mode, margin: &quot; + sorted.vec[0] + &quot;, npos: &quot; + posCount + &quot;, nneg: &quot; + negCount);
                this.selectedQuestionIdx &#x3D; sorted.perm[0];
                return this.selectedQuestionIdx;
            }

        };
        // asks the user for class label given a record set index
        //!   - &#x60;alModel.getAnswer(ALAnswer, recSetIdx)&#x60; -- given user input &#x60;ALAnswer&#x60; (string) and &#x60;recSetIdx&#x60; (integer, result of model.selectQuestion) the training set is updated.
        //!      The user input should be either &quot;y&quot; (indicating that recSet[recSetIdx] is a positive example), &quot;n&quot; (negative example).
        this.getAnswer &#x3D; function (ALanswer, recSetIdx) {
            //todo options: ?newQuery
            if (ALanswer &#x3D;&#x3D;&#x3D; &quot;y&quot;) {
                posIdxV.push(recSetIdx);
                posRecIdV.push(uRecSet[recSetIdx].$id);
                //X.push(ftrSpace.extractSparseVector(uRecSet[recSetIdx]));
                X.push(uMat.getCol(recSetIdx));
                y.push(1.0);
            } else {
                negIdxV.push(recSetIdx);
                negRecIdV.push(uRecSet[recSetIdx].$id);
                //X.push(ftrSpace.extractSparseVector(uRecSet[recSetIdx]));
                X.push(uMat.getCol(recSetIdx));
                y.push(-1.0);
            }
            // +k query // rank unlabeled according to query, ask for k most similar
            // -k query // rank unlabeled according to query, ask for k least similar
        };
        //!   - &#x60;alModel.startLoop()&#x60; -- starts the active learning loop in console
        this.startLoop &#x3D; function () {
            while (true) {
                var recSetIdx &#x3D; this.selectQuestion();
                var ALanswer &#x3D; sget(uRecSet[recSetIdx].Text + &quot;: y/(n)/s? Command s stops the process&quot;).trim();
                if (ALanswer &#x3D;&#x3D; &quot;s&quot;) { break; }
                if (posIdxV.length + negIdxV.length &#x3D;&#x3D; uRecSet.length) { break; }
                this.getAnswer(ALanswer, recSetIdx);
            }
        };
        //!   - &#x60;alModel.saveSvmModel(fout)&#x60; -- saves the binary SVM model to an output stream &#x60;fout&#x60;. The algorithm must be in SVM mode.
        this.saveSvmModel &#x3D; function (outputStream) {
            // must be in SVM mode
            if (queryMode) {
                console.log(&quot;AL.save: Must be in svm mode&quot;);
                return;
            }
            svm.save(outputStream);
        };

        this.getWeights &#x3D; function () {
            return svm.weights;
        }
        //this.saveLabeled
        //this.loadLabeled
    };

    
</code></pre>
            </article>
                                        </div>
                                </div>
                                <nav id="jsdoc-toc-nav" role="navigation"></nav>
                        </div>
                </div>
                    <footer id="jsdoc-footer" class="jsdoc-footer">
                            <div id="jsdoc-footer-container">
                                    <p>
                                      
                                    </p>
                            </div>
                    </footer>
                <script src="scripts/jquery.min.js"></script>
                <script src="scripts/jquery.cookie.js"></script>
                <script src="scripts/tree.jquery.js"></script>
                <script src="scripts/prettify.js"></script>
                <script src="scripts/jsdoc-toc.js"></script>
                <script src="scripts/linenumber.js"></script>
                <script src="scripts/scrollanchor.js"></script>
        </body>
</html>
