
QMiner functionality is accessible through a JavaScript API. The JavaScript environment
is similar to Node.js, but omits any functionality not necessary for QMiner's core tasks.
The API includes a simple HTTP server with RESTful web-service support for defining
application specific web-service APIs.

The JavaScript API is implemented using [V8 JavaScript Engine](https://code.google.com/p/v8/),
which lives in the same process as core QMiner objects. This allows for fast manipulation
of QMiner objects, since data is moved from C++ to JavaScript and back only when needed.
Currently, version 3.18 of V8 is used.

JavaScript API requires [initialized work environment](Quick-Start).
    
## Libraries

Scripts can load external libraries or modules in the same way as Node.js.

Library is loaded using `require` function:
```JavaScript
var test = require('testModule.js');
```

Modules export functionality by defining properties or functions on the `exports` object, 
for example (taken from Node.js documentation):
```JavaScript
var PI = Math.PI;
exports.area = function (r) {
  return PI * r * r;
};
exports.circumference = function (r) {
  return 2 * PI * r;
};
```

Libraries are loaded from two places. The first is project's library folder (`src/lib/`) 
and the second is QMiner library folder (`QMINER_HOME/lib/`). Project's library folder 
has priority in case the library with the same name exists in both places. Some libraries 
are implemented in C++, for example `analytics` and `time`.

The QMiner system comes with the following libraries:
- `analytics.js` -- main API for analytics techniques
- `utilities.js` -- useful JavaScript utilities, e.g., checking variable type
- `time` -- wrapper around user-friendly date-time object
- `assert.js` -- support for writing unit tests

## Core QMiner objects

### QMiner

QMiner (`qm`) is the core object in the API and is available in any script.

**Functions and properties:**

- `s = qm.store(storeName)` -- store with name `storeName`; `null` when no such store
- `a = qm.getStoreList()` -- an array listing all existing stores
- `qm.createStore(storeDef)` -- create new store(s) based on given [definition](Store Definition)
- `rs = qm.search(query)` -- execute `query` specified in [QMiner Query Language](Query Language) 
  and returns a record set `rs` with results
-- `qm.gc()` -- start garbage collection to remove records outside time windows
- `qm.load.jsonFileLimit(store, fileName, limit)` -- load file `fileName` 
  line by line, parsing each line as JSON and adding it as record to `store`.
  When `limit != -1` only first first `limit` lines are loaded
- `qm.load.jsonFile(store, fileName)` -- load file `fileName` line by line, 
  parsing each line as JSON and adding it as record to `store`
- `qm.printStreamAggr(store)` -- prints all current field values of every stream aggregate attached to the store `store`

### Store

Store holds records. Each record has a unique 64-bit ID. Record ID can be used to directly
access the record from the store using index operator:
```JavaScript
var store = qm.store("storeName");
var record = store[1234];
```

**Functions and properties:**
    
- `store.name` -- name of the store
- `store.empty` -- `true` when store is empty
- `store.length` -- number of records in the store
- `rs = store.recs` -- create a record set containing all the records from the store
- `store.fields` -- array of all the field names
- `store.joins` -- array of all the join names
- `store.keys` -- array of all the [index keys](#index-key)
- `r = store[recordId]` -- get record with ID `recordId`; 
    returns `null` when no such record exists
- `r = store.rec(recordName)` -- get record named `recordName`; 
    returns `null` when no such record exists
- `store.add(record)` -- add `record` to the store 
- `r = store.newRec(recordJson)` -- creates new record by value (not added to the store)
- `r = store.newRec(recordIds)` -- creates new record set from array of record IDs;
    array is expected to be of type `la.newIntVec`
- `rs = store.sample(sampleSize)` -- create a record set containing a random 
    sample of `sampleSize` records
- `field = store.field(fieldName)` -- get details of field named `fieldName`
- `key = store.key(keyName)` -- get [index key](#index-key) named `keyName`
- `store.addTrigger(trigger)` -- add `trigger` to the store triggers
- `store.addStreamAggr(TypeName, Parameters);` -- add new [Stream Aggregate](Stream-Aggregates) 
    of type `TypeName` to the store; stream aggregate is passed `Parameters` JSon
- `sa = store.getStreamAggr(Name)` -- returns current value of stream aggregate `Name`
- `arr = store.getStreamAggrNames()` -- returns the names of all stream aggregators as an array of strings `arr`

**Examples**:

```JavaScript
// adding new record
qm.store("Movies").add({
  Title: "The Hobbit: An Unexpected Journey", 
  Year: 2012, 
  directedBy: {
    Name: "Peter Jackson",
    Gender: "Male"
  }
}

// adding a trigger
qm.store("People").addTrigger({
  onAdd : function (person) { console.log("New record: " + person.Name); },
  onUpdate : function (person) { console.log("Updated record: " + person.Name); },
  onDelete : function (person) { console.log("Deleted record: " + person.Name); }
});

// iterating over records
var rs = qm.store("People");
for (var i = 0; i < rs.length; i++) {
  var rec = rs[i];
  console.log(rec.Name + " (" + rec.Gender + ")");
}
```    

### Record set

Record set holds a subset of records from a store. Records are stored in a vector. 
It can also hold a vector of aggregates, which were computed over the records from 
the set.

**Functions and properties:**
  
- `rs.store` -- store of the records
- `rs.length` -- number of records in the set
- `rs.empty` -- `true` when record set is empty
- `rs.weighted` -- true when records in the set are assigned weights
- `rec = rs[n]` -- return n-th record from the record set
- `crs = rs.clone()` -- creates new instance of record set
- `jrs = rs.join(JoinName)` -- executes a join `JoinName` on the records in the set, result is another record set
- `jrs = rs.join(JoinName, SampleSize)` -- executes a join `JoinName` on a sample of `SampleSize` records in the set, result is another record set
- `aggr = rs.aggr()` -- returns an array of all the aggregates contained in the records set
- `aggr = rs.aggr(Query)` -- creates a new aggregates based on the `Query` parameters
- `rs.trunc(Recs)` -- truncate to first `Recs` record
- `srs = rs.sample(Recs)` -- create new record set by randomly sampling `Recs` records
- `rs.shuffle(Seed)` -- shuffle order using random seed `Seed`
- `rs.reverse()` -- reverse record order
- `rs.sortById(Asc)` -- sort records according to record id; if `Asc > 0` sorted in ascending order
- `rs.sortByFq(Asc)` -- sort records according to weight; if `Asc > 0` sorted in ascending order
- `rs.sortByField(FieldName, Asc)` -- sort records according to value of field `FieldName`; if `Asc > 0` sorted in ascending order
- `rs.sort(comparator)` -- sort records according to `comparator` callback
- `rs.filterById(minId, maxId)` -- keeps only records with ids between `minId` and `maxId`
- `rs.filterByFq(minFq, maxFq)` -- keeps only records with weight between `minFq` and `maxFq`
- `rs.filterByField(FieldName, minVal, maxVal)` -- keeps only records with numeric value of field `FieldName` between `minVal` and `maxVal`
- `rs.filterByField(FieldName, Val)` -- keeps only records with string value of field `FieldName` equal to `Val`
- `rs.filter(filter)` -- keeps only records that pass `filter` callback
- `rs.deleteRecs(rs2)` -- delete from `rs` records that are also in `rs2`
- `rs.toJSON()` -- provide json version of record set, useful when calling JSON.stringify

**Examples**:

```JavaScript
TODO
```        

### Record


**Functions and properties:**
  
- `rec.$id`
- `rec.$name`
- `rec.$fq`
- `rec.fieldName`
- `rec.joinName`
- `rec.addJoin(joinName, joinRecord)`
- `rec.addJoin(joinName, joinRecord, joinFrequency)`
- `rec.delJoin(joinName, joinRecord)`
- `rec.delJoin(joinName, joinRecord, joinFrequency)`
- `rec.toJSON()` -- provide json version of record, useful when calling JSON.stringify

### Index key


**Functions and properties:**
  
- `key.store`    
- `key.name`    
- `key.voc`    
- `key.fq`    

## Linear Algebra

A global object `la` is used to construct vectors (sparse, dense) and matrices and 
it is available in any script. The object includes
several functions from linear algebra.

**Functions and properties:**

- `vec = la.newVec()` -- generate an empty float vector
- `vec = la.newVec({"vals":k, "mxvals":l})` -- generate a vector with `k` zeros and reserve additional `l-k` elements 
- `vec = la.newVec(a)` -- copy a javascript number array `a` 
- `vec = la.newVec(vec2)` -- clone a float vector `vec2`
- `vec = la.newIntVec()` -- generate an empty float vector
- `vec = la.newIntVec({"vals":k, "mxvals":l})` -- generate a vector with `k` zeros and reserve additional `l-k` elements 
- `vec = la.newIntVec(a)` -- copy a javascript int array `a` 
- `vec = la.newIntVec(vec2)` -- clone an int vector `vec2`
- `mat = la.newMat()` -- generates a 0x0 matrix
- `mat = la.newMat(a)` -- generates a matrix from a javascript array `a`, whose elements are arrays of numbers which correspond to matrix rows (row-major dense matrix)
- `mat = la.newMat({"rows":r, "cols":c, "random":b})` -- creates a matrix with `r` rows and `c` columns and sets it to zero if the optional "random" property is set to `false` (default) and uniform random if "random" is `true`
- `mat = la.newMat(mat2)` -- clones a dense matrix `mat2`
- `vec = la.newSpVec(dim)` -- creates an empty sparse vector `vec`, where `dim` is an optional (-1 by default) integer parameter that sets the dimension
- `vec = la.newSpVec(a, dim)` -- creats a sparse vector `vec` from a javascript array `a`, whose elements are javascript arrays with two elements (integer row index and double value). `dim` is optional and sets the dimension
- `mat = la.newSpMat()` -- creates an empty sparse matrix `mat`
- `mat = la.newSpMat(rowIdxV, colIdxV, valV)` -- creates an sparse matrix based on two int vectors `rowIdxV` (row indices) and `colIdxV` (column indices) and float vector of values `valV`
- `mat = la.newSpMat(a, r)` -- creates an sparse matrix with `r` rows (optional parameter), where `a` is a javascript array of arrays that correspond to sparse matrix columns and each column is a javascript array of arrays corresponding to nonzero elements. Each element is an array of size 2, where the first number is an int (row index) and the second value is a number (value). Example: `mat = linalg.newSpMat([[[0, 1.1], [1, 2.2], [3, 3.3]], [[2, 1.2]]], { "rows": 4 });`
- `mat = la.newSpMat({"rows":r, "cols":c}) --- creates a sparse matrix with `c` columns and `r` rows, which should be integers
- `res = la.svd(mat, k, {"iter":iter, "tol":tol})` -- Computes a truncated svd decomposition mat ~ U S V^T.  `mat` is a sparse or dense matrix, integer `k` is the number of singular vectors, optional parameter object contains integer number of iterations `iter` (default 2) and the tolerance number `tol` (default 1e-6). The outpus are stored as two dense matrices: `res.U`, `res.V` and a dense float vector `res.s`.
- `la.printVec(vec)` -- print the vector in the console, `vec` can be int or float vector
- `la.printArray(arr)` -- print the javascript array `arr` in the console
- `la.printMat(matrix)` -- print the `matrix` (dense or sparse) in the console as a dense matrix
- `x = la.genRandom()` -- `x` is a sample from a standard normal random variable
- `vec = la.genRandomVector(dim)` -- `vec` is a dense vector whose elements are independent samples from a standard normal random variable and whos dimension is `dim`
- `p = la.genRandomPerm(k)` -- returns a permutation of `k` elements. `p` is a javascript array of integers
- `i = la.randInt(n)` -- returns an integer `i` which is randomly selected from the set of integers `[0, ..., n-1]`
- `vec = la.randIntVec(n, k)` -- returns a JS array `vec`, which is a sample of `k` numbers from `[0,...,n-1]`, sampled without replacement. `k` must be smaller or equal to `n`
- `mat = la.genRandomMatrix(rows, cols)` -- `mat` is a dense matrix whose elements are independent samples from a standard normal random variable, with `rows` rows and `cols` columns (integers)
- `I = la.eye(dim)` -- `I` is a `dim`-by-`dim` identity matrix
- `vec = la.ones(k)` -- `vec` is a `k`-dimensional vector whose entries are set to `1.0`.
- `vec = la.rangeVec(min, max)` -- `vec` is an integer(!) vector: `[min, min+1,..., max]`.
- `la.square(vec)` -- when `vec` is a vector, squares all elements of a vector (inplace)
- `sq = la.square(num)` -- when `num` is a number, `sq = num * num`.
- `idxArray = la.findMaxIdx(X)` -- returns a JS array of indices `idxArray` that correspond to the max elements in each column of dense matrix `X`. If `X` is a dense vector, the result has one element.
- `vec = la.copyIntArrayToVec(arr)` -- copies a JS array of integers `arr` into an integer vector `vec`
- `vec = la.copyFltArrayToVec(arr)` -- copies a JS array of numbers `arr` into a float vector `vec`
- `la.saveMat(X, fout)` -- writes a matrix `X` to output file stream `fout`
- `la.conjgrad(A,b,x)` -- solves the system A*x = b, where `A` is a matrix (sparse or dense) and `b` and `x` are dense vectors

### Vector

Vector is an array of objects implemented in glib/base/ds.h. 
Some functions are implemented for float vectors only. Using the global `la` object, flaot and int vectors can be generated in the following ways:

```JavaScript
var fltv = la.newVec(); //empty vector
var intv = la.newIntVec(); //empty vector
// refer to la.newVec, la.newIntVec functions for alternative ways to generate vectors
```


**Functions and properties:**

- `x = vec.at(elN)` -- gets the value `x` at index `elN` of vector `vec` (0-based indexing)
- `x = vec[elN]; vec[elN] = y` -- get value `x` at index `elN`, set value at index `elN` to `y` of vector `vec`(0-based indexing)
- `vec.put(elN, y)` -- set value at index `elN` to `y` of vector `vec`(0-based indexing)
- `vec.push(y)` -- append value `y` to vector `vec`
- `vec.unshift(y)` -- insert value `y` to the begining of vector `vec`. Returns the length of the modified array.
- `vec.pushV(vec2)` -- append vector `vec2` to vector `vec`. Implemented for dense integer and dense float vectors.
- `x = vec.sum()` -- sums the elements of `vec`
- `idx = vec.getMaxIdx()` -- returns the integer index `idx` of the maximal element in `vec`
- `vec2 = vec.sort(asc)` -- `vec2` is a sorted copy of `vec`. `asc=true` sorts in ascending order (equivalent `sort()`), `asc`=false sorts in descending order
- `res = vec.sortPerm(asc)` -- returns a sorted copy of the vector in `res.vec` and the permutation `res.perm`. `asc=true` sorts in ascending order (equivalent `sortPerm()`), `asc`=false sorts in descending order. Implemented for dense float vectors.
- `mat = vec1.outer(vec2)` -- the dense matrix `mat` is a rank-1 matrix obtained by multiplying `vec1 * vec2^T`. Implemented for dense float vectors. 
- `x = vec1.inner(vec2)` -- `x` is the standard dot product between vectors `vec1` and `vec2`. Implemented for dense float vectors.
- `vec3 = vec1.plus(vec2)` --`vec3` is the sum of vectors `vec1` and `vec2`. Implemented for dense float vectors.
- `vec3 = vec1.minus(vec2)` --`vec3` is the difference of vectors `vec1` and `vec2`. Implemented for dense float vectors.
- `vec2 = vec1.multiply(a)` --`vec2` is a vector obtained by multiplying vector `vec1` with a scalar (number) `a`. Implemented for dense float vectors.
- `vec.normalize();` -- normalizes the vector `vec` (inplace operation). Implemented for dense float vectors.
- `len = vec.length` -- integer `len` is the length of vector `vec`
- `vec.print()` -- print vector in console
- `D = vec.diag()` -- `D` is a diagonal dense matrix whose diagonal equals `vec`. Implemented for dense float vectors.
- `D = vec.spDiag()` -- `D` is a diagonal sparse matrix whose diagonal equals `vec`. Implemented for dense float vectors.
- `x = vec.norm()` -- `x` is the Euclidean norm of `vec`. Implemented for dense float vectors.
- `vec2 = vec.sparse()` -- `vec2` is a sparse vector representation of dense vector `vec`. Implemented for dense float vectors.

### Matrix (dense matrix)

Matrix is a double 2D array implemented in glib/base/ds.h. 
Using the global `la` object, dense matrices are generated in several ways:

```JavaScript
var fltv = la.newVec(); //empty matrix
// refer to la.newMat function for alternative ways to generate dense matrices
```


**Functions and properties:**

- `val = mat.at(i,j)` -- Gets the element of `mat` (matrix). Input: row index `i` (integer), column index `j` (integer). Output: `val` (number). Uses zero-based indexing.
- `mat.put(i, j, val)` -- Sets the element of `mat` (matrix). Input: row index `i` (integer), column index `j` (integer), value `val` (number). Uses zero-based indexing.
- `y = mat.multiply(x)` -- Matrix multiplication: if `x` is a number, then `y` is a matrix. If `x` is a vector (dense or sparse), then `y` is a dense vector. If `x` is a matrix (sparse or dense), then `y` is a dense matrix.
- `y = mat.multiplyT(x)` -- the result is equivalent to mat.transpose().multiply(), supported inputs include a number (scalar), dense or sparse vector and dense or sparse matrix. The result is always dense.
- `mat3 = mat1.plus(mat2)` -- `mat3` is the sum of matrices `mat1` and `mat2`
- `mat3 = mat1.plus(mat2)` -- `mat3` is the difference of matrices `mat1` and `mat2`
- `mat2 = mat.transpose()` -- matrix `mat2` is matrix `mat1` transposed
- `x = mat.solve(y)` -- vector `x` is the solution to the linear system `mat * x = y`
- `vec = mat.rowNorms()` -- `vec` is a dense vector, where `vec[i]` is the norm of the `i`-th row of `mat`
- `vec = mat.colNorms()` -- `vec` is a dense vector, where `vec[i]` is the norm of the `i`-th column of `mat`
- `mat.normalizeCols()` -- normalizes each column of matrix `mat` (inplace operation)
- `spMat = mat.sparse()` -- get sparse column matrix representation `spMat` of dense matrix `mat`
- `x = mat.frob()` -- number `x` is the Frobenious norm of matrix `mat`
- `r = mat.rows` -- integer `r` corresponds to the number of rows of `mat`
- `c = mat.cols` -- integer `c` corresponds to the number of columns of `mat`
- `str = mat.printStr()` -- print matrix `mat` to a string `str`
- `mat.print()` -- print matrix `mat` to console
- `i = mat.rowMaxIdx(j)`: get the index `i` of the maximum element in row `j` of dense matrix `mat`
- `i = mat.colMaxIdx(j)`: get the index `i` of the maximum element in column `j` of dense matrix `mat`
- `vec = mat.getCol(i)` -- `vec` corresponds to the `i`-th column of dense matrix `mat`. `i` must be an integer.
- `mat.setCol(i, vec)` -- Sets the column of a dense matrix `mat`. `i` must be an integer, `vec` must be a dense vector.
- `vec = mat.getRow(i)` -- `vec` corresponds to the `i`-th row of dense matrix `mat`. `i` must be an integer.
- `mat.setRow(i, vec)` -- Sets the row of a dense matrix `mat`. `i` must be an integer, `vec` must be a dense vector.

### SpVector (sparse vector)

Sparse vector is an array of (int,double) pairs that represent column indices and values (TIntFltKdV is implemented in glib/base/ds.h.)
Using the global `la` object, sparse vectors can be generated in the following ways:

```JavaScript
var spVec = la.newSpVec(); //empty vector
// refer to la.newSpVec for alternative ways to generate sparse vectors
```


**Functions and properties:**

- `val = spVec.at(i)` -- Gets the element of a sparse vector `spVec`. Input: index `i` (integer). Output: value `val` (number). Uses 0-based indexing
- `spVec.put(i, val)` -- Set the element of a sparse vector `spVec`. Inputs: index `i` (integer), value `val` (number). Uses 0-based indexing
- `x = spVec.sum()` -- `x` is the sum of elements of `spVec`
- `x = spVec.inner(y)` -- `x` is the inner product between `spVec` and vector (sparse or dense) `y`.
- `spVec2 = spVec.multiply(a)` -- `spVec2` is sparse vector, a product between `a` (number) and vector `spVec`
- `spVec.normalize()` -- normalizes the vector spVec (inplace operation)
- `n = spVec.nnz` -- gets the number of nonzero elements `n` of vector `spVec`
- `d = spVec.dim` -- gets the dimension `d` (-1 means that it is unknown)
- `spVec.print()` -- prints the vector to console
- `x = spVec.norm()` -- returns `x` - the norm of `spVec`
- `vec = spVec.full()` --  returns `y` - a dense vector representation of sparse vector `spVec`.

### SpMatrix (sparse column matrix)

SpMatrix is a sparse matrix represented as a dense vector of sparse vectors which correspond to matrix columns (TVec<TIntFltKdV>, implemented in glib/base/ds.h.)
Using the global `la` object, sparse matrices are generated in several ways:

```JavaScript
var spMat = la.newSpMat(); //empty matrix
// refer to la.newSpMat function for alternative ways to generate sparse matrices
```


**Functions and properties:**

- `val = spMat.at(i,j)` -- Gets the element of `spMat` (sparse matrix). Input: row index `i` (integer), column index `j` (integer). Output: `val` (number). Uses zero-based indexing.
- `spMat.put(i, j, val)` -- Sets the element of `spMat` (sparse matrix). Input: row index `i` (integer), column index `j` (integer), value `val` (number). Uses zero-based indexing.
- `x = spMat[i]; spMat[i] = x` -- setting and getting sparse vectors `x` from sparse column matrix, given column index `i` (integer)
- `spMat.push(x)` -- attaches a column `x` (sparse vector) to `spMat` (sparse matrix)
- `y = spMat.multiply(x)` -- Matrix multiplication: if `x` is a number, then `y` is a matrix. If `x` is a vector (dense or sparse), then `y` is a dense vector. If `x` is a matrix (sparse or dense), then `y` is a dense matrix.
- `y = spMat.multiplyT(x)` -- the result is equivalent to mat.transpose().multiply(), supported inputs include a number (scalar), dense or sparse vector and dense or sparse matrix. The result is always dense.
- `spMat3 = spMat1.plus(spMat2)` -- `spMat3` is the sum of matrices `spMat1` and `spMat2` (all matrices are sparse column matrices)
- `spMat3 = spMat1.minus(spMat2)` -- `spMat3` is the difference of matrices `spMat1` and `spMat2` (all matrices are sparse column matrices)
- `spMat2 = spMat.transpose()` -- `spMat2` (sparse matrix) is `mat1` (sparse matrix) transposed 
- `vec = spMat.colNorms()` -- `vec` is a dense vector, where `vec[i]` is the norm of the `i`-th column of `spMat`
- `spMat.normalizeCols()` -- normalizes each column of a sparse matrix `spMat` (inplace operation)
- `mat = spMat.full()` -- get dense matrix representation `mat` of `spMat (sparse column matrix)`
- `x = spMat.frob()` -- number `x` is the Frobenious norm of `spMat` (sparse matrix)
- `r = spMat.rows` -- integer `r` corresponds to the number of rows of `spMat` (sparse matrix)
- `c = spMat.cols` -- integer `c` corresponds to the number of columns of `spMat` (sparse matrix)
- `spMat.print()` -- print `spMat` (sparse matrix) to console
- `la.spMat` -- the prototype object for sparse column matrices. Implemented in spMat.js, every sparse matrix inherits from it.
- `spMat.toString()` -- displays rows, columns and number of non-zero elements of a sparse column matrix `spMat`
- `var n = spMat.nnz();` -- `n` is the number of non-zero elements of sparse column matrix `spMat`

## Analytics.js (use require)

Analytics algorithms for working with records stored in
QMiner and with linear algebra objects created by `la`.

To start using it must be loaded using `var analytics = require('analytics.js');`.

**Functions and properties:**
    
- `fs = analytics.newFeatureSpace(featureExtractors)` -- create new
    feature space consisting of [Feature Extractor](Feature-Extractors),
    declared in JSon `featureExtractors`
- `fs = analytics.loadFeatureSpace(fin)` -- load serialized feature 
    space from `fin` stream
- `model = analytics.trainSvmClassify(matrix, vector, parameters)` -- trains binary
    classification model using columns from `matrix` as training data and
    `vector` as target variable (must be of values either 1 or -1); optional
    training `parameters` are a JSon with parameter `c` (SVM cost parameter,
    default = 1.0) and `j` (factor to multiply SVM cost parameter for positive 
    examples with (default is 1.0)); result is a linear model
- `model = analytics.trainSvmRegression(matrix, vector, parameters)` -- trains 
    regression model using columns from `matrix` as training data and `vector` as 
    target variable; optional training `parameters` are a JSon with parameter `c` 
    (SVM cost parameter, default = 1.0) and `eps` (ignore threshold defining
    epsilon size tunnel around the model, default is 1.0)); result is a linear model
- `model = analytics.loadSvmModel(fin)` -- load serialized linear model 
    from `fin` stream
- `model = analytics.newRecLinReg(parameters)` -- create new recursive linear regression
    model; training `parameters` are `dim` (dimensionality of feature space, e.g.
    `fs.dim`), `forgetFact` (forgetting factor, default is 1.0) and `regFact` 
    (regularization parameter to avoid over-fitting, default is 1.0).)
- `model = analytics.loadRecLinRegModel(fin)` -- load serialized linear model
    from `fin` stream
- `model = analytics.newHoeffdingTree(jsonStream, jsonParams)` -- create new
    incremental decision tree learner; parameters are passed as JSON
- `options = analytics.getLanguageOptions()` -- get options for text parsing 
    (stemmers, stop word lists) as a json object, with two arrays:
    `options.stemmer` and `options.stopwords`
- `model = analytics.newBatchModel(records, features, target)` -- learns a new batch model
    using `records` as training data and `features` as feature space; `target` is
    a field for the records which we are trying to predict (e.g. store.field("Rating");
    if target field string or string vector, the result is a SVM classification model,
    and if target field is a float, the result is a SVM regression model; resulting 
    model has the following functions:
  - `model.target` -- array of categories for which we have models
  - `result = model.predict(record)` -- creates feature vector from `record`, sends it
    through the model and returns the result as an array of scores.
  - `result = model.predictTop(record)` -- creates feature vector from `record`, 
    sends it through the model and returns the top ranked label.
  - `model.save(fout)` -- saves the model to `fout` output stream
- `analytics.loadBatchModel(fin)` -- loads batch model frm input stream `fin`
- `model = new analytics.activeLearner(ftrSpace, textField, recSet, nPos, nNeg, query)` -- starts the
   active learning. The algorithm has two stages: query mode, where the algorithm suggests potential
   positive and negative examples based on the query text, and SVM mode, where the algorithm keeps
  selecting examples that are closest to the SVM margin (every time an example is labeled, the SVM
  is retrained.
  The inputs are the feature space `ftrSpace`, `textField` (string) which is the name
   of the field in records that is used to create feature vectors, `recSet` (record set) a set of records from a store
   that is used as unlabeled data, `nPos` (integer) and `nNeg` (integer) set the number of positive and negative
   examples that have to be identified in the query mode before the program enters SVM mode. The final
  parameter is the `query` (string) which should be related to positive examples.
- `model = new analytics.ridgeRegression(kappa, dim, buffer)` -- solves a regularized ridge
 regression problem: min|X'w - y|^2 + kappa |w|^2. The inputs to the algorithm are: `kappa`, the regularization parameter,
 `dim` the dimension of the model and (optional) parameter `buffer` (integer) which specifies
 the length of the window of tracked examples (useful in online mode). The model exposes the following functions:
-- `model.add(x, y)` -- adds a vector `x` (sparse or dense) and target `y` (number) to the training set
-- `model.addupdate(x, y)` -- adds a vector `x` (sparse or dense) and target `y` (number) to the training set and retrains the model
-- `model.forget(n)` -- deletes first `n` (integer) examples from the training set
-- `model.update()` -- recomputes the model
-- `w = model.getModel()` -- returns the parameter vector `w` (dense vector)
-- `w = model.compute(A, b)` -- computes the model parameters `w`, given 
   a column training example matrix `A` (dense or sparse matrix) and target 
   vector `b` (dense vector). The vector `w` solves min_w |A'w - b|^2 + kappa |w|^2.
-- `p = model.predict(x)` -- predicts the target `p` (number), given feature vector `x` based on the internal model parameters.
- `C = new analytics.kmeans(X, k, iter)`-- solves the k-means algorithm based on a training
  set `X` (sparse or dense matrix) where colums represent examples, `k` (integer) the number of centroids and
  `iter` (integer), the number of iterations. The solution `C` is a dense matrix, where each column
   is a cluster centroid.
- `model = new analytics.lloyd(dim, k)` -- online clustering based on the Lloyd alogrithm. The model intialization
 requires `dim` (integer) the dimensionality of the inputs and `k` (integer), number of centroids. The model exposes the following functions:
-- `model.init()` -- initializes the model with random centroids
-- `C = model.getC()` -- returns the centroid matrix `C` (dense matrix)
-- `model.setC(C)` -- sets the centroid matrix to `C` (dense matrix)
-- `model.update(x)` -- updates the model with a vector `x` dense or sparse
-- `c = model.getCentroids(x)` -- returns the centroid `c` (dense vector) that is the closest to vector `x` (sparse or dense)
-- `i = model.getCentroidIdx(x)` -- returns the centroid index `i` (integer) that corresponds to the centroid that is the closest to vector `x` (sparse or dense)
- `model = new analytics.perceptron(dim, use_bias)` -- the perceptron learning algorithm initialization requires
  specifying the problem dimensions `dim` (integer) and optionally `use_bias` (boolean, default=false). The
  model is used to solve classification tasks, where classifications are made by a function class(x) = sign(w'x + b). The following functions are exposed:
-- `model.update(x,y)` -- updates the internal parameters `w` and `b` based on the training feature vector `x` (dense or sparse vector) and target class `y` (0 or 1)! 
-- `class = model.predict(x)` -- returns the prediction (0 or 1)
-- `param = model.getModel()` -- returns an object `param` where `param.w` (vector) and `param.b` (bias) are the separating hyperplane normal and bias. 

### Feature Space

Holds the definition of the feature space and feature extractors, which
can create feature vectors from QMiner records. Feature space is created
by calling `analytics.newFeatureSpace` and providing [Feature Extractor](Feature-Extractors) 
declarations as parameters.

**Functions and properties:**
    
- `fs.dim` -- dimensionality of feature space
- `fs.save(fout)` -- serialize feature space to `fout` output stream
- `fs.updateRecord(record)` -- update feature space definitions and extractors
    by exposing them to `record`. For example, this can update the vocabulary
    used by bag-of-words extractor by taking into account new text.
- `fs.updateRecord(recordSet)` -- update feature space definitions and extractors
    by exposing them to records from `recordSet`. For example, this can update 
    the vocabulary used by bag-of-words extractor by taking into account new text.
- `strVec = fs.extractStrings(record)` -- use feature extractors to extract string 
    features from `record` (e.g. words from string fields); results are returned
    as a string array
- `spVec = ftrSpVec(record)` -- extracts sparse feature vector from `record`
- `vec = ftrVec(record)` -- extracts feature vector from `record`
- `spMatrix = ftrSpColMat(recordSet)` -- extracts sparse feature vectors from 
    records in `recordSet` and returns them as columns in a sparse matrix.
- `matrix = ftrColMat(recordSet)` -- extracts feature vectors from 
    records in `recordSet` and returns them as columns in a matrix.

### Support Vector Machine model

Holds SVM classification or regression model. This object is result of
`analytics.trainSvmClassify` or `analytics.trainSvmRegression`.

**Functions and properties:**
    
- `res = model.predict(vector)` -- sends `vector` (full or sparse) through the 
    model and returns the prediction as a real number
- `vec = model.weights` -- weights of the SVM linear model as a full vector
- `model.save(fout)` -- saves model to output stream `fout`

### Recursive Linear Regression model

Holds online regression model. This object is result of `analytics.newRecLinReg`.

**Functions and properties:**
    
- `model.learn(vector, target)` -- updates the model using full `vector` as
    `target` number as training data
- `res = model.predict(vector)` -- sends `vector` (full or sparse) through the 
    model and returns the prediction as a real number
- `vec = model.weights` -- weights of the linear model as a full vector    
- `model.dim` -- dimensionality of the feature space on which this model works
- `model.save(fout)` -- saves model to output stream `fout`

### Hoeffding Tree model

First, we have to initialize the learner. 
We specify the order of attributes in a stream example, and describe each attribute.
For each attribute, we specifty its type and --- in case of discrete attributes --- enumerate
all possible values of the attribute. See titanicConfig below. 

The HoeffdingTree algorithm comes with many parameters:

- gracePeriod. Denotes ``recomputation period''; if gracePeriod=200, the algorithm
	    will recompute information gains (or Gini indices) every 200 examples. Recomputation
	    is the most expensive operation in the algorithm; we have to recompute gains at each
	    leaf of the tree. (If ConceptDriftP=true, in each node of the tree.)
- splitConfidence. The probability of making a mistake when splitting a leaf. Let A1 and A2
	    be attributes with the highest information gains G(A1) and G(A2). The algorithm
	    uses [Hoeffding inequality](http://en.wikipedia.org/wiki/Hoeffding's_inequality#General_case)
	    to ensure that the attribute with the highest estimate (estimate is computed form the sample
	    of the stream examples that are currently in the leaf) is truly the best (assuming the process
	    generating the data is stationary). So A1 is truly best with probability at least 1-splitConfidence.
- tieBreaking. If two attributes are equally good --- or almost equally good --- the algorithm will
	    will never split the leaf. We address this with tieBreaking parameter and consider two attributes
	    equally good whenever G(A1)-G(A2) <= tieBreaking, i.e., when they have similar gains. (Intuition: If
	    the attributes are equally good, we don't care on which one we split.)
- conceptDriftP. Denotes whether the algorithm adapts to potential changes in the data. If set to true,
	    we use a variant of [CVFDT learner](http://homes.cs.washington.edu/~pedrod/papers/kdd01b.pdf );
    if set to false, we use a variant of [VFDT learner](http://homes.cs.washington.edu/~pedrod/papers/kdd00.pdf).
- driftCheck. If DriftCheckP=true, the algorithm sets nodes into self-evaluation mode every driftCheck
	    examples and swaps the tree 
- windowSize. The algorithm keeps a sliding window of the last windowSize stream examples. It makes sure
	    the model reflects the concept represented by the examples from the sliding window. It needs to keep
	    the window in order to ``forget'' the example when it becomes too old. 

**Functions and properties:**
    
- `ht.process(discreteV, numericV, label)` -- processes the stream example; `discreteV` is vector of discrete attribute values;
  `numericV` is vector of numeric attribute values; `label` is class label of the example; returns nothing;
- `ht.process(line)` -- processes the stream example; `line` is comma-separated string of attribute values (for example "a1,a2,c", where c is the class label); returns nothing;
- `ht.classify(discreteV, numericV)` -- classifies the stream example; `discreteV` is vector of discrete attribute values; `numericV` is vector of numeric attribute values; returns the class label 
- `ht.classify(line)` -- classifies the stream example; `line` is comma-separated string of attribute values; returns the class label 
- `ht.exportModel(outParams)` -- writes the current model into file `outParams.file` in format `outParams.type`;
  here, `outParams = { file: filePath, type: exportType }` where `file` is the file path and `type` is the export type (currently only `DOT` or `XML` supported) 

## System and I/O

### Process


**Functions and properties:**

- `process.sleep(millis)` -- Halts execution for the given amount of milliseconds `millis`.
- `a = process.args` -- array of command-line arguments 
    used to start current QMiner instance
- `process.isArg(arg)` -- returns true when `arg` among the 
    command-line arguments used to start current QMiner instance
- `process.sysStat` -- statistics about system and qminer process (E.g. memory consumption).

### Utilities.js (use require)

- `utilities.isObject(arg)` -- is parameter an object?
- `utilities.isArray(arg)` -- is parameter an array?
- `utilities.isInArray(array, value)` -- is element in an array?
- `utilities.isNumber(n)` -- is `n` a number?
- `utilities.isString(s)` -- is `s` a string?
- `utilities.ifNull(val, defVal)` -- checks if `val` is null and returns default value `defVal`
- `h = new utilities.hashTable()` -- creates a hash table
 - `utilities.hashTable._vals` -- 
 - `utilities.hashTable.keys` -- 
 - `utilities.hashTable.vals` -- 
 - `utilities.hashTable.put(key)` -- 
 - `utilities.hashTable.put(key, dat)` -- 
 - `utilities.hashTable.contains(key)` -- 
 - `utilities.hashTable.get(key)` -- 
- `sw = new utilities.clsStopwatch()` -- creates a stop watch object `sw`
- `sw.start()` --
- `sw.stop()` --
- `sw.reset()` --
- `sw.time()` --
- `sw.saytime(msg)` --
- `sw.tic()` --
- `sw.toc(msg)` --
- `q = utilities.arraysIdentical(arr1, arr2)` -- `q` is true if array `arr1` is identical to array `arr2`

### Assert.js (use require)


### Console

Writing and reading from console. Also very useful to create
"interactive breakpoints" using `console.start()`. All outputs
are automatically prefixed by current date and time.

**Functions and properties:**
    
- `console.log(message)` -- writes `message` to standard output, using
    prefix `[console]` to indicate the text came from console object;
    `message` must be of type string
- `console.log(prefix, message)` -- writes `message` to standard output, 
    using provided prefix `[prefix]`; both `message` and `prefix` must
    be of type string
- `line = console.getln()` -- reads a line from command line and returns
    it as string
- `console.print(str)` -- prints a string to standard output
- `console.start()` - start interactive console; does not see local variables.
    Receiving empty imput (Enter was pressed) exits the interactive mode.
- `console.startx(evalFun)` -- useful for debugging;
    insert in code: `console.startx(function (x) { return eval(x); })`
    in order for console to see and interact with local variables.
    Receiving empty imput (Enter was pressed) exits the interactive mode.
- `console.pause()` -- waits until enter is pressed

### File system


**Functions and properties:**
    
- `fin = fs.openRead(fileName)`
- `fout = fs.openWrite(fileName)`
- `fout = fs.openAppend(fileName)`
- `fs.exists(fileName)`
- `fs.copy(fromFileName, toFileName)`
- `fs.move(fromFileName, toFileName)`
- `fs.del(fileName)`
- `fs.rename(fromFileName, toFileName)`
- `info = fs.fileInfo(fileName,)`
- `fs.mkdir(dirName)`
- `fs.rmdir(dirName)`
- `list = fs.listFile(dirName, fileExtension)`
- `list = fs.listFile(dirName, fileExtension, recursive)`

### Input File Stream


**Functions and properties:**
    
- `char = fin.peekCh()`
- `char = fin.getCh()`
- `line = fin.readLine()`
- `fin.eof`
- `fin.length`

### Output File Stream


**Functions and properties:**
    
- `fout.write(data)`
- `fout.writeLine(data)`
- `fout.flush()`
- `fout.close()`

### HTTP


**Functions and properties:**
    
- `http.get(url)`
- `http.get(url, success_callback)`
- `http.get(url, success_callback, error_callback)`
- `http.getStr(url)`
- `http.getStr(url, success_callback)`
- `http.getStr(url, success_callback, error_callback)`
- `http.post(url, mimeType, data)`
- `http.post(url, mimeType, data, success_callback)`
- `http.post(url, mimeType, data, success_callback, error_callback)`
- `http.postStr(url)`
- `http.postStr(url, mimeType, data, success_callback)`
- `http.postStr(url, mimeType, data, success_callback, error_callback)`
- `http.onRequest(path, verb, function (request, response) { ... })`
- `onGet(path, function (request, response) { ... })`
- `onPost(path, function (request, response) { ... })`
- `onPut(path, function (request, response) { ... })`
- `onDelete(path, function (request, response) { ... })`
- `onPatch(path, function (request, response) { ... })`
- `jsonp(request, response, data)` -- packaging reply as jsonp when callback parameter is provided in URL

### HTTP Response


**Functions and properties:**
    
- `resp.setStatusCode(statusCode)`
- `resp.setStatusCode(mimeType)`
- `resp.add(data)`
- `resp.close()`
- `resp.send(data)`

### Date-Time

Wrapper around GLib's TTm. Used as return for `DateTime` field type. 
New one can be created using `tm = require('time')`.

**Functions and properties:**

- `tm.string` -- string representation of time (e.g. 2014-05-29T10:09:12)
- `tm.dateString` -- string representation of date (e.g. 2014-05-29)
- `tm.timestamp` -- unix timestamp representation of time (seconds since 1970)
- `tm.year`
- `tm.month`
- `tm.day`
- `tm.dayOfWeek`
- `tm.hour`
- `tm.minute`
- `tm.second`
- `tm.milisecond`
- `tm.now` -- returns new time object representing current local time
- `tm.nowUTC` -- returns new time object represented current UTC time
- `tm.add(val, unit)` -- adds `val` to the time; `unit` defines the unit 
    of `val`, options are `second` (default), `minute`, `hour`, and `day`.
- `tm.sub(val, unit)` -- subtracts `val` from the time; `unit` defines the 
    unit, same as in `add`
- `tm.toJSON()` -- returns json representation of time    
- `date = tm.parse(`2014-05-29T10:09:12`) -- parses string and returns it
    as Date-Time object
