<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Example</title>
    <style>
        @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700);
        @import url(http://square.github.io/cubism/style.css);
    </style>
</head>
<body>
    <h1>
        Storage and stream aggregator example
    </h1>
    <p>
        This is a visual representation of our storage and stream aggregators. In our base, we save random values
        from the interval [-100, 100]. When we graph these values, the graph is really spikey and we cannot tell
        anything about the values.
    </p>
    <p>
        This is where our stream aggregators come in handy. By using the <b>moving average</b> stream aggregator, we smoothen
        the values and then we can tell something about the values.
    </p>
    <p>
        The graphs bellow represent the original and the smoothen values.
    </p>
    <h2>Time Series Visualization</h2>
    <div id="values" style="position:relative"></div>

    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://square.github.io/cubism/cubism.v1.js"></script>

    <!-- Cubism script -->
    <script>

        var socket = io(); var stat, smooth, now, origin;
        socket.on('getValues', function (incomingData) {
            stat = incomingData.stat;
            smooth = incomingData.smooth;
            now = incomingData.now;
            origin = incomingData.origin;
        });

        var statList = { val: stat, time: now };
        var smoothList = {val: smooth, time: now };

        function getData(name, title) {

            var values = [],
                last;

            return context.metric(function (start, stop, step, callback) {
                start = +start, stop = +stop;
                if (isNaN(last)) { last = start; }
                while (last < stop) {
                    last += step;
                    if (name == "stat") { value = stat; }
                    else if (name == "smooth") { value = smooth; }
                    values.push(value);
                }
                callback(null, values = values.slice((start - stop) / step));
            }, title);
        }

    </script>
    <script>
        //// create a context for inserting values
        //// serverDelay - the delay on the server side
        //// clientDelay - the delay on the client side
        var context = cubism.context()
            .serverDelay(0)
            .clientDelay(0)
            .step(100)
            .size(960);

        var values = getData("stat", "Original");
        var average = getData("smooth", "Smoothen");

        d3.select("#values").call(function (div) {
            div.append("div").attr("class", "axis").call(context.axis().orient("top"));

            div.selectAll(".horizon").data([values, average]).enter().append("div")
                .attr("class", "horizon").call(context.horizon()
                .extent([-400, 400]).height(100));

            div.append("div").attr("class", "rule").call(context.rule());
        });

    </script>

</body>
</html>